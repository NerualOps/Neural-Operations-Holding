<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- Primary SEO Meta Tags -->
    <title>Owner Dashboard - Neural Operations | Admin Control Panel</title>
    <meta name="title" content="Owner Dashboard - Neural Operations | Admin Control Panel">
    <meta name="description" content="Neural Operations owner dashboard for managing AI systems, analytics, and business intelligence. Administrative access to Epsilon AI and Neural CRM platforms.">
    <meta name="keywords" content="Neural Operations admin, owner dashboard, AI system management, business analytics dashboard">
    <meta name="robots" content="noindex, nofollow">
    <meta name="author" content="Neural Operations & Holdings LLC">
    <link rel="canonical" href="https://neuralops.biz/owner">
    
    <!-- WebPage Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebPage",
      "name": "Owner Dashboard - Neural Operations",
      "description": "Administrative dashboard for AI system management",
      "url": "https://neuralops.biz/owner",
      "isPartOf": {
        "@type": "WebSite",
        "name": "Neural Operations",
        "url": "https://neuralops.biz"
      }
    }
    </script>
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://neuralops.biz/owner">
    <meta property="og:title" content="Owner Dashboard - Neural Operations">
    <meta property="og:description" content="Administrative dashboard for AI system management">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary">
    <meta property="twitter:url" content="https://neuralops.biz/owner">
    <meta property="twitter:title" content="Owner Dashboard - Neural Operations">
    <meta property="twitter:description" content="Administrative dashboard for AI system management">
    
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <!-- Performance: Resource Hints -->
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    
    <!-- Async Font Loading -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700;800;900&family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    <noscript><link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700;800;900&family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet"></noscript>
    
    <style>
        /* Professional Design System - Ignition Precision */
        :root {
            --flame-core: #F97316;
            --flame-highlight: #FF8A3D;
            --flame-deep: #C2410C;
            --near-black: #0F0F0F;
            --soft-white: #FAFAFA;
            --ash-neutral: #A1A1AA;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--near-black);
            color: var(--soft-white);
            line-height: 1.6;
            padding-top: 2rem;
        }

        /* Navigation Styles - Matching epsilon.html */
        .top-left-nav { position: fixed; top: 1.5rem; left: 1.5rem; z-index: 2000; transition: left 0.35s ease; }
        .top-nav-button { 
            padding: 0.6rem 1.2rem; 
            background: transparent; 
            border: 1px solid var(--ash-neutral); 
            border-radius: 6px; 
            color: var(--soft-white); 
            text-decoration: none; 
            font-size: 0.85rem; 
            font-weight: 500; 
            transition: all 0.15s ease-out; 
        }
        .top-nav-button:hover { 
            border-color: var(--flame-core); 
            color: var(--flame-core); 
            background: rgba(249, 115, 22, 0.05);
        }

        /* Owner Profile Navigation */
        .owner-profile-nav {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            z-index: 2001;
        }

        .profile-circle {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: var(--flame-core);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .profile-circle:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .profile-circle span {
            color: white;
            font-weight: 600;
            font-size: 1rem;
        }

        .owner-dropdown {
            position: absolute;
            top: 55px;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 0.5rem;
            min-width: 200px;
            display: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            z-index: 2002;
        }

        .owner-dropdown.active {
            display: block;
        }

        .owner-dropdown-item {
            display: block;
            padding: 0.75rem 1rem;
            color: rgba(255, 255, 255, 0.9);
            text-decoration: none;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .owner-dropdown-item:hover {
            background: rgba(249, 115, 22, 0.1);
        }

        .owner-dropdown-item.logout {
            color: #ff3b30;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 0.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.35rem;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.75);
        }

        .form-select,
        .form-input,
        .form-textarea {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: var(--soft-white);
            padding: 0.75rem 0.85rem;
            font-size: 0.95rem;
            font-family: inherit;
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        .form-select:focus,
        .form-input:focus,
        .form-textarea:focus {
            outline: none;
            border-color: var(--flame-core);
            box-shadow: 0 0 0 2px rgba(249, 115, 22, 0.1);
        }

        .form-select option {
            background: #0a0a0f !important;
            color: #ffffff !important;
        }
        
        .form-select {
            background-color: rgba(255, 255, 255, 0.05) !important;
            color: #ffffff !important;
        }
        
        .form-select:hover {
            background-color: rgba(255, 255, 255, 0.08) !important;
        }

        .form-textarea {
            min-height: 90px;
            resize: vertical;
        }

        .documents-panel {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .document-select-container {
            width: 100%;
        }

        .documents-list {
            width: 320px;
            max-height: 520px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 18px;
            padding: 1rem;
        }

        .documents-list::-webkit-scrollbar {
            width: 6px;
        }

        .documents-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .document-list-item {
            width: 100%;
            border: 1px solid transparent;
            border-radius: 12px;
            padding: 0.9rem;
            margin-bottom: 0.65rem;
            text-align: left;
            background: rgba(255, 255, 255, 0.03);
            color: var(--soft-white);
            cursor: pointer;
            transition: border 0.2s ease, background 0.2s ease, transform 0.15s ease;
        }

        .document-list-item:last-child {
            margin-bottom: 0;
        }

        .document-list-item.active {
            border-color: var(--flame-core);
            background: rgba(249, 115, 22, 0.05);
            box-shadow: 0 0 16px rgba(249, 115, 22, 0.15);
        }

        .document-list-item .doc-title {
            font-weight: 600;
            margin-bottom: 0.2rem;
            font-size: 0.95rem;
        }

        .document-list-item .doc-meta {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.65);
        }

        .document-detail-card {
            flex: 1;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 18px;
            padding: 1.5rem;
            min-height: 360px;
        }

        .document-detail-header {
            display: flex;
            justify-content: space-between;
            gap: 1rem;
            align-items: flex-start;
        }

        .document-type-pill {
            padding: 0.35rem 0.9rem;
            border-radius: 999px;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .document-detail-meta {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 1rem;
            margin: 1.25rem 0;
        }

        .document-detail-meta p {
            margin-bottom: 0.2rem;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .document-detail-meta strong {
            font-size: 0.95rem;
        }

        .document-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            margin-bottom: 1rem;
        }

        .document-tag {
            font-size: 0.75rem;
            padding: 0.25rem 0.7rem;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.08);
        }

        .document-action-row {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .action-btn.outline {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: var(--soft-white);
        }

        .document-empty-state {
            text-align: center;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            border: 1px dashed rgba(255, 255, 255, 0.2);
        }

        @media (max-width: 1024px) {
            .documents-panel {
                flex-direction: column;
            }

            .documents-list {
                width: 100%;
                max-height: 220px;
            }
        }

        .nav {
            position: fixed;
            top: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            width: min(1180px, calc(100% - 2.5rem));
            max-width: 100%;
            background: rgba(10, 10, 18, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 54px;
            padding: 0.9rem 1.35rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.65rem;
            flex-wrap: nowrap;
            backdrop-filter: blur(30px) saturate(1.2);
            box-shadow:
                0 12px 38px rgba(0, 0, 0, 0.55),
                0 4px 16px rgba(0, 0, 0, 0.32),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
            transition: all 0.35s ease;
        }

        .nav-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            width: 100%;
        }

        .nav:hover {
            transform: translateX(-50%) translateY(-4px);
            border-color: rgba(255, 255, 255, 0.2);
            box-shadow:
                0 18px 48px rgba(0, 0, 0, 0.65),
                0 6px 18px rgba(0, 0, 0, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.12);
        }

        .logo {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.35rem;
            font-weight: 700;
            color: var(--soft-white);
            text-decoration: none;
            letter-spacing: 0.02em;
            margin-right: 1rem;
        }

        .nav-menu {
            display: flex;
            gap: 0.3rem;
            list-style: none;
            flex: 1;
            justify-content: center;
            align-items: center;
        }

        .nav-link {
            color: rgba(255, 255, 255, 0.82);
            text-decoration: none;
            font-size: 0.95rem;
            font-weight: 500;
            padding: 0.7rem 0.95rem;
            border-radius: 28px;
            position: relative;
            transition: all 0.3s ease;
            white-space: nowrap;
            letter-spacing: 0.02em;
        }

        .nav-link::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 32px;
            background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0));
            opacity: 0;
            transition: opacity 0.35s ease;
        }

        .nav-link:hover::before,
        .nav-link.active::before {
            opacity: 1;
        }

        .nav-link.active {
            color: #fff;
        }

        @media (max-width: 1280px) {
            .nav {
                width: min(1000px, calc(100% - 2.25rem));
                padding: 0.85rem 1.2rem;
                gap: 0.55rem;
            }

            .nav-link {
                padding: 0.6rem 0.85rem;
            font-size: 0.9rem;
            }

            .contact-btn {
                padding: 0.55rem 1.05rem;
                font-size: 0.85rem;
        }

            .profile-btn {
                padding: 0.5rem 0.75rem;
                gap: 0.35rem;
        }

        .profile-name {
                display: none;
            }
        }

        .nav-actions {
            display: flex;
            align-items: center;
            gap: 0.65rem;
            flex-wrap: nowrap;
        }

        .contact-btn {
            background: var(--flame-core);
            color: #fff;
            padding: 0.6rem 1.4rem;
            border-radius: 28px;
            text-decoration: none;
            font-weight: 600;
            font-size: 0.9rem;
            box-shadow:
                0 0 16px rgba(249, 115, 22, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.18);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            white-space: nowrap;
        }

        @media (max-width: 1100px) {
            .contact-btn {
                display: none;
            }
        }

        .contact-btn:hover {
            transform: translateY(-2px);
            box-shadow:
                0 0 15px rgba(249, 115, 22, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.22);
        }

        .mobile-menu-btn {
            display: none;
            background: none;
            border: none;
            color: var(--soft-white);
            font-size: 1.4rem;
            cursor: pointer;
            padding: 0.4rem;
            border-radius: 10px;
            transition: background 0.3s ease;
        }

        .mobile-menu-btn:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .mobile-menu-btn span {
            display: block;
            width: 24px;
            height: 3px;
            margin: 4px 0;
            border-radius: 2px;
            background: var(--neural-text);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .mobile-menu-btn.active span:nth-child(1) {
            transform: rotate(-45deg) translate(-5px, 6px);
        }

        .mobile-menu-btn.active span:nth-child(2) {
            opacity: 0;
        }

        .mobile-menu-btn.active span:nth-child(3) {
            transform: rotate(45deg) translate(-5px, -6px);
        }

        .mobile-menu {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(5, 6, 12, 0.96);
            backdrop-filter: blur(20px);
            z-index: 999;
            padding: 2.5rem 2rem;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
        }
        
        .mobile-menu.active {
            display: flex;
        }

        .mobile-menu a {
            color: #fff;
            text-decoration: none;
            font-size: 1.3rem;
            padding: 0.85rem 1.8rem;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 100%;
            max-width: 320px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .mobile-menu a:hover {
            background: rgba(249, 115, 22, 0.08);
            color: var(--secondary);
        }

        @media (max-width: 1024px) {
            body {
                padding-top: 110px;
        }

            .nav {
                padding: 0.9rem 1.25rem;
            gap: 1rem;
            }

            .nav-menu,
            .nav-actions {
                display: none;
            }

            .mobile-menu-btn {
            display: flex;
                flex-direction: column;
                justify-content: center;
            align-items: center;
                gap: 4px;
            }

            .dashboard-container {
                padding: 1.75rem;
                gap: 1.5rem;
        }

            .dashboard-main {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }

            .overview-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
                gap: 1.25rem;
            }
        }

        @media (max-width: 768px) {            
            .dashboard-container {
                padding: 1.25rem;
                gap: 1.25rem;
        }

        .welcome-section {
                padding: 1.25rem;
            }

            .dashboard-section {
                padding: 1.35rem;
        }
        
            .admin-actions {
                grid-template-columns: 1fr;
                gap: 1rem;
        }

            .admin-card {
                padding: 1.5rem;
        }

        .stats-grid {
                grid-template-columns: 1fr;
            gap: 1rem;
            }

            .learning-metrics-grid {
                grid-template-columns: 1fr;
        }

        .stat-card {
            padding: 1.5rem;
            }

            .upload-options {
                flex-direction: column;
                gap: 1rem;
        }

            .upload-option {
                padding: 1.5rem;
            }

            .system-status {
                padding: 1.5rem;
        }

            .status-item {
            padding: 1rem;
            }

            .overview-grid {
                grid-template-columns: 1fr;
        }
        }

        @media (max-width: 480px) {
            .logo {
                font-size: 1.2rem;
            }

            .dashboard-container {
                padding: 1rem;
        }

            .admin-card, .stat-card, .upload-option {
                padding: 1rem;
            }

            .system-status {
            padding: 1rem;
        }

            .status-item {
            padding: 0.8rem;
            }

            .stats-grid,
            .learning-metrics-grid {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }

            .stat-card {
            padding: 1rem;
            }

            .stat-number {
                font-size: 1.5rem;
        }

        .connection-status {
                position: relative;
                top: auto;
                right: auto;
                margin-bottom: 1rem;
                display: inline-block;
            }

            .welcome-title {
                font-size: 1.6rem;
            }

            .welcome-subtitle {
                font-size: 0.95rem;
            }
        }

        .profile-dropdown {
            position: relative;
        }

        .profile-btn {
            display: flex;
            align-items: center;
            gap: 0.55rem;
            padding: 0.5rem 0.9rem;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: rgba(255, 255, 255, 0.05);
            color: var(--soft-white);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .profile-btn:hover,
        .profile-btn.active {
            border-color: var(--flame-core);
            background: rgba(249, 115, 22, 0.05);
            box-shadow: 0 0 24px rgba(249, 115, 22, 0.15);
        }

        .profile-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            line-height: 1;
            background: var(--flame-core);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.22);
        }

        .dropdown-arrow {
            font-size: 0.7rem;
            transition: transform 0.3s ease;
        }

        .profile-btn.active .dropdown-arrow {
            transform: rotate(180deg);
        }

        .profile-menu {
            position: absolute;
            top: calc(100% + 0.75rem);
            right: 0;
            min-width: 230px;
            background: rgba(8, 10, 20, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 18px;
            box-shadow: 0 18px 38px rgba(0, 0, 0, 0.45);
            padding: 0.9rem;
            display: none;
            flex-direction: column;
            gap: 0.35rem;
            z-index: 1200;
        }

        .profile-btn.active + .profile-menu,
        .profile-menu.show {
            display: flex;
        }

        .profile-menu-item,
        .logout-item {
            display: flex;
            align-items: center;
            gap: 0.55rem;
            padding: 0.55rem 0.8rem;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.85);
            background: transparent;
            border: none;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.25s ease;
        }

        .profile-menu-item:hover,
        .logout-item:hover {
            background: rgba(249, 115, 22, 0.08);
            color: #fff;
        }

        .logout-item {
            color: var(--neural-error);
        }

        .profile-menu-divider {
            height: 1px;
            margin: 0.4rem 0;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 999px;
        }

        .dashboard-container {
            max-width: 1180px;
            margin: 0 auto 4rem;
            padding: 2.75rem 0 2.5rem;
            display: none;
            flex-direction: column;
            gap: 2.2rem;
        }

        .welcome-section {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 2rem;
            padding: 2.25rem 2.5rem;
            background: linear-gradient(135deg, rgba(0, 40, 120, 0.55), rgba(0, 18, 65, 0.75));
            border-radius: 32px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 24px 55px rgba(0, 0, 0, 0.35);
            position: relative;
            overflow: hidden;
        }

        .welcome-section::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(120% 120% at 80% 20%, rgba(255, 138, 61, 0.15) 0%, transparent 55%);
            pointer-events: none;
        }

        .welcome-content {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            gap: 0.85rem;
            max-width: 720px;
        }

        .welcome-title {
            font-size: 2.1rem;
            font-weight: 700;
            letter-spacing: 0.01em;
        }

        .welcome-subtitle {
            color: rgba(224, 233, 255, 0.8);
            font-size: 1rem;
            line-height: 1.65;
        }

        .welcome-user {
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.72);
        }

        .welcome-meta {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .epsilon-pill {
            display: inline-flex;
            align-items: center;
            gap: 0.45rem;
            padding: 0.45rem 0.95rem;
            border-radius: 999px;
            font-size: 0.85rem;
            font-weight: 600;
            background: rgba(100, 140, 200, 0.08);
            border: 1px solid var(--flame-core);
        }

        .crm-coming {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.4rem 0.85rem;
            border-radius: 999px;
            font-size: 0.85rem;
            font-weight: 500;
            text-decoration: none;
            color: rgba(255, 255, 255, 0.86);
            background: rgba(255, 255, 255, 0.07);
            border: 1px dashed rgba(255, 255, 255, 0.22);
            transition: all 0.25s ease;
        }

        .crm-coming:hover {
            background: rgba(249, 115, 22, 0.1);
            border-style: solid;
        }

        .refresh-btn {
            position: relative;
            z-index: 1;
            align-self: flex-start;
            padding: 0.55rem 1.3rem;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .refresh-btn:hover {
            background: rgba(249, 115, 22, 0.08);
            border-color: var(--flame-core);
            box-shadow: 0 0 24px rgba(249, 115, 22, 0.15);
        }

        .dashboard-section {
            background: rgba(10, 12, 22, 0.92);
            border-radius: 28px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            padding: 1.9rem 2.1rem;
            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.35);
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .section-title {
            font-size: 1.3rem;
            font-weight: 600;
            letter-spacing: 0.02em;
        }

        .stats-grid,
        .learning-metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1.25rem;
        }

        .stat-card,
        .metric-card {
            position: relative;
            padding: 1.4rem 1.5rem;
            border-radius: 22px;
            background: linear-gradient(135deg, rgba(0, 80, 220, 0.16), rgba(0, 24, 64, 0.24));
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
            display: flex;
            flex-direction: column;
            gap: 0.65rem;
        }

        .stat-label {
            font-size: 0.85rem;
            color: rgba(214, 224, 255, 0.7);
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .stat-number {
            font-size: 1.9rem;
            font-weight: 700;
            letter-spacing: 0.02em;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .stat-item {
            background: rgba(249, 115, 22, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 1.2rem;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--soft-white);
            margin-bottom: 0.5rem;
        }

        .stat-change {
            font-size: 0.85rem;
            color: rgba(0, 255, 136, 0.85);
            font-weight: 600;
        }

        .admin-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1rem;
        }

        .action-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.45rem;
            padding: 0.85rem 1.1rem;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: rgba(249, 115, 22, 0.05);
            color: #fff;
            font-weight: 600;
            font-size: 0.95rem;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            transition: all 0.3s ease;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 24px rgba(249, 115, 22, 0.15);
        }

        .action-btn[data-state="loading"] {
            position: relative;
            pointer-events: none;
            opacity: 0.65;
        }

        .action-btn[data-state="loading"]::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 18px;
            height: 18px;
            margin: -9px 0 0 -9px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.25);
            border-top-color: #fff;
            animation: spin 0.6s linear infinite;
        }

        .action-btn[data-state="success"] {
            background: rgba(0, 210, 140, 0.18);
            border: 1px solid rgba(0, 210, 140, 0.5);
            box-shadow: 0 12px 28px rgba(0, 210, 140, 0.22);
        }

        .action-btn[data-state="error"] {
            background: rgba(255, 76, 76, 0.14);
            border: 1px solid rgba(255, 76, 76, 0.4);
            box-shadow: 0 12px 28px rgba(255, 76, 76, 0.2);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .upload-section {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 22px;
            padding: 2.25rem;
            background: rgba(255, 255, 255, 0.04);
            text-align: center;
            color: rgba(255, 255, 255, 0.76);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: var(--flame-core);
            background: rgba(249, 115, 22, 0.1);
            color: #fff;
        }

        .upload-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 1.25rem;
        }

        .upload-option {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 18px;
            padding: 1.75rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.45rem;
        }

        label {
            font-size: 0.85rem;
            font-weight: 600;
            color: rgba(214, 224, 255, 0.78);
            letter-spacing: 0.02em;
        }

        .form-select,
        .form-input,
        .form-textarea {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 0.65rem 0.85rem;
            color: #fff;
            font-size: 0.95rem;
            transition: border 0.3s ease, box-shadow 0.3s ease;
        }

        .form-select:focus,
        .form-input:focus,
        .form-textarea:focus {
            outline: none;
            border-color: var(--flame-core);
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.15);
        }

        .form-textarea {
            min-height: 120px;
            resize: vertical;
        }

        .learning-metrics-footnote {
            font-size: 0.85rem;
            color: rgba(190, 200, 220, 0.7);
        }

        .loading {
            color: rgba(210, 220, 245, 0.75);
            font-style: italic;
        }

        .automatic-training-status {
            margin-top: 2rem;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            background: rgba(10, 10, 18, 0.6);
            backdrop-filter: blur(10px);
        }

        .status-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .status-icon {
            font-size: 1.5rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--soft-white);
            flex: 1;
        }

        .status-badge {
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
            background: rgba(0, 153, 255, 0.2);
            border: 1px solid rgba(0, 153, 255, 0.4);
            color: rgba(200, 225, 255, 0.9);
        }

        .status-badge.training {
            background: rgba(0, 210, 140, 0.2);
            border-color: rgba(0, 210, 140, 0.4);
            color: rgba(196, 255, 232, 0.9);
        }

        .status-badge.idle {
            background: rgba(136, 146, 176, 0.2);
            border-color: rgba(136, 146, 176, 0.4);
            color: rgba(200, 210, 230, 0.9);
        }

        .status-details {
            margin-top: 1rem;
        }

        .status-message {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.95rem;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        .status-progress {
            margin-top: 1rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--flame-core);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .status-log {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .log-header {
            font-size: 0.9rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 0.75rem;
        }

        .log-entries {
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .log-entry {
            padding: 0.6rem 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .log-entry.success {
            border-left-color: var(--neural-success);
        }

        .log-entry.error {
            border-left-color: var(--neural-error);
        }

        .log-entry-time {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }

        .train-status {
            display: none;
            align-items: center;
            gap: 0.65rem;
            margin-top: 1rem;
            padding: 0.8rem 1rem;
            border-radius: 14px;
            font-size: 0.92rem;
            font-weight: 500;
            letter-spacing: 0.02em;
            transition: all 0.3s ease;
        }

        .train-status .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .train-status.status-info {
            display: flex;
            background: rgba(0, 153, 255, 0.12);
            border: 1px solid rgba(0, 153, 255, 0.35);
            color: rgba(200, 225, 255, 0.92);
        }

        .train-status.status-info .status-dot {
            background: #3ba9ff;
        }

        .train-status.status-success {
            display: flex;
            background: rgba(0, 210, 140, 0.12);
            border: 1px solid rgba(0, 210, 140, 0.4);
            color: rgba(196, 255, 232, 0.95);
        }

        .train-status.status-success .status-dot {
            background: #00d28c;
        }

        .train-status.status-error {
            display: flex;
            background: rgba(255, 76, 76, 0.12);
            border: 1px solid rgba(255, 76, 76, 0.4);
            color: rgba(255, 214, 214, 0.95);
        }

        .train-status.status-error .status-dot {
            background: #ff4c4c;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            z-index: 10000;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(10, 12, 22, 0.98), rgba(5, 8, 16, 0.98));
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 24px;
            padding: 2rem;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 24px 60px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--soft-white);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }

        /* Table Styles */
        .analytics-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            }

        .analytics-table thead {
            background: rgba(249, 115, 22, 0.05);
            border-bottom: 1px solid var(--flame-core);
        }

        .analytics-table th {
                padding: 1rem;
            text-align: left;
            font-weight: 600;
            color: var(--soft-white);
            font-size: 0.9rem;
            letter-spacing: 0.02em;
            }

        .analytics-table td {
            padding: 0.85rem 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.85);
            font-size: 0.9rem;
            }

        .analytics-table tbody tr {
            transition: background 0.2s ease;
            }

        .analytics-table tbody tr:hover {
            background: rgba(255, 255, 255, 0.05);
            }

        .analytics-table tbody tr:last-child td {
            border-bottom: none;
            }

        .error-message {
            color: var(--neural-error);
                padding: 1rem;
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid rgba(255, 68, 68, 0.3);
            border-radius: 12px;
            margin-top: 1rem;
            }

        /* Performance optimizations */
        * {
            will-change: auto;
            }

        .dashboard-section,
        .modal-content {
            contain: layout style paint;
            }

        /* Connection status */
        .connection-status {
            position: fixed;
            top: 1rem;
            right: 1rem;
            padding: 0.6rem 1.2rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
            z-index: 9999;
            transition: all 0.3s ease;
        }

        .connection-status.loading {
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid rgba(255, 170, 0, 0.4);
            color: #ffaa00;
            }

        .connection-status.connected {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid rgba(0, 255, 136, 0.4);
            color: #00ff88;
            }

        .connection-status.disconnected {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid rgba(255, 68, 68, 0.4);
            color: #ff4444;
        }

        /* Site Footer */
        .site-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(10, 15, 25, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            padding: 0.75rem 2rem;
            z-index: 100;
        }

        .footer-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .footer-left {
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
        }

        .footer-left p {
            margin: 0;
        }

        .footer-right {
            display: flex;
            align-items: center;
        }

        .footer-links {
            display: flex;
            gap: 2rem;
            align-items: center;
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .footer-link {
            color: rgba(255, 255, 255, 0.5);
            text-decoration: none;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
        }

        .footer-link:hover {
            color: rgba(255, 255, 255, 0.8);
        }

        .footer-divider {
            color: rgba(255, 255, 255, 0.3);
            margin: 0;
            display: flex;
            align-items: center;
            line-height: 1;
        }

        @media (max-width: 768px) {
            .site-footer {
                padding: 0.5rem 1rem;
            }

            .footer-content {
                flex-direction: column;
                gap: 0.5rem;
                text-align: center;
            }

            .footer-links {
                gap: 1rem;
            }
        }
    </style>
</head>
<body>
    <div id="connectionStatus" class="connection-status loading">Checking connection...</div>
    
    <div class="top-left-nav"><a href="/" class="top-nav-button">← Home</a></div>
    
    <!-- Profile Circle Navigation -->
    <div class="owner-profile-nav">
        <div class="profile-circle" id="ownerProfileCircle" onclick="toggleOwnerDropdown()">
            <span id="ownerInitials">O</span>
                </div>
        <div class="owner-dropdown" id="ownerDropdown">
            <div id="ownerDropdownName" style="padding: 0.75rem 1rem; color: rgba(255, 255, 255, 0.9); font-weight: 600; border-bottom: 1px solid rgba(255, 255, 255, 0.1);">Owner</div>
            <a href="/" class="owner-dropdown-item">Home</a>
            <a href="/epsilon" class="owner-dropdown-item">Epsilon AI</a>
            <a href="/about" class="owner-dropdown-item">About Us</a>
            <a href="/contact" class="owner-dropdown-item">Contact Us</a>
            <div style="border-top: 1px solid rgba(255, 255, 255, 0.1); margin: 0.5rem 0;"></div>
            <a href="/edit_profile" class="owner-dropdown-item">Edit Profile</a>
            <a href="/owner" class="owner-dropdown-item" id="ownerLink" style="display: none;">Owner Dashboard</a>
            <a href="#" class="owner-dropdown-item logout" id="ownerLogout">Logout</a>
            </div>
    </div>

    <div class="dashboard-container">
        <div class="welcome-section">
            <div class="welcome-content">
                <h1 class="welcome-title">Owner Control Center</h1>
                <p class="welcome-subtitle">Monitor platform performance, orchestrate Epsilon AI's learning pipeline, and align intelligence outputs with your growth strategy.</p>
                <span class="welcome-user" id="user-welcome"></span>
                <div class="welcome-meta">
                    <span class="epsilon-pill" id="epsilonVersionLabel">Epsilon AI Core v1.0</span>
                    <a href="#" class="crm-coming" id="crmComingBtn">
                        CRM Workspace
                        <span>Coming Soon</span>
                    </a>
                </div>
            </div>
            <button class="refresh-btn" id="refreshBtn">Refresh Data</button>
        </div>

        <div class="dashboard-section">
            <h2 class="section-title">Platform Overview</h2>
            <div id="stats-container">
                <div class="loading">Loading analytics...</div>
            </div>
        </div>

        <div class="dashboard-section">
            <h2 class="section-title">Epsilon AI Learning Metrics</h2>
            <div class="learning-metrics-grid" id="learningMetricsGrid">
                <div class="loading">Calculating learning metrics...</div>
            </div>
            <div class="learning-metrics-footnote" id="learningMetricsFootnote"></div>
        </div>

        <div class="dashboard-section">
            <h2 class="section-title">Admin Actions</h2>
            <div class="admin-actions">
                <a href="/" class="action-btn">Visit Main Site</a>
                <button class="action-btn" id="downloadAnalyticsBtn" type="button">Export Analytics</button>
                <button class="action-btn" id="viewUsersBtn" type="button">View All Users</button>
                <a href="/contact" class="action-btn">View Contact Requests</a>
            </div>
            
            <!-- Automatic Training Status Bar -->
            <div class="automatic-training-status" id="automaticTrainingStatus">
                <div class="status-header">
                    <span class="status-icon" id="trainingStatusIcon">⟳</span>
                    <span class="status-title">Epsilon AI Automatic Training</span>
                    <span class="status-badge" id="trainingStatusBadge">Initializing...</span>
                </div>
                <div class="status-details" id="trainingStatusDetails">
                    <div class="status-message" id="trainingStatusMessage">Setting up automatic training system...</div>
                    <div class="status-progress" id="trainingStatusProgress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="trainingProgressFill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
                <div class="status-log" id="trainingStatusLog" style="display: none;">
                    <div class="log-header">Training Activity Log</div>
                    <div class="log-entries" id="trainingLogEntries"></div>
                </div>
            </div>
        </div>

        <div class="dashboard-section">
            <h2 class="section-title">Knowledge Management</h2>
            <button class="refresh-btn" id="refreshDocumentsBtn">Refresh Documents</button>
            
            <div class="upload-section">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-content">
                        <h3>Upload AI Learning Documents</h3>
                        <p>Drag & drop files here or click to browse</p>
                        <small>Supports: PDF, TXT, DOCX, MD (Max 7.5GB each)</small>
                    </div>
                </div>
                
                <form id="uploadForm" enctype="multipart/form-data">
                    <input type="file" id="fileInput" name="file" multiple accept=".pdf,.txt,.docx,.md" style="display: none;">
                    
                    <div class="upload-options">
                        <div class="form-group">
                            <label for="learningCategory">Learning Category:</label>
                            <select id="learningCategory" name="learning_category" class="form-select" required>
                                <option value="">Select Learning Category</option>
                                <option value="knowledge">Knowledge Base Documents</option>
                                <option value="sales_training">Sales Training & Tone</option>
                                <option value="learning">General Learning Documents</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="docType">Document Type:</label>
                            <select id="docType" name="document_type" class="form-select" required>
                                <option value="">Select Document Type</option>
                                <option value="dictionary">Dictionary (Word Definitions)</option>
                                <option value="knowledge_base">Knowledge Base</option>
                                <option value="pricing">Pricing Information</option>
                                <option value="technical">Technical Documentation</option>
                                <option value="process">Process Documentation</option>
                                <option value="faq">FAQ Content</option>
                                <option value="case_study">Case Studies</option>
                                <option value="sales_script">Sales Scripts</option>
                                <option value="communication_guide">Communication Guide</option>
                                <option value="training_material">Training Material</option>
                                <option value="best_practices">Best Practices</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="docDescription">Description (Optional):</label>
                            <textarea id="docDescription" name="description" class="form-textarea" placeholder="Brief description of the document content..."></textarea>
                        </div>
                        
                        <div class="form-group">
                            <label for="docTags">Tags (Optional):</label>
                            <input type="text" id="docTags" name="tags" class="form-input" placeholder="Enter tags separated by commas (e.g., sales, training, communication)">
                        </div>
                        
                        <button type="button" class="action-btn" id="uploadBtn" disabled>
                            Upload & Start Learning
                        </button>
                    </div>
                </form>

                <div id="uploadProgress" class="upload-progress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-text" id="progressText">Processing documents...</div>
                    <div class="progress-details" id="progressDetails" style="margin-top: 0.5rem; font-size: 0.9rem; color: rgba(255,255,255,0.7);">
                        <span id="progressPercent">0%</span> - <span id="progressTime">Calculating...</span>
                    </div>
                </div>
            </div>

            <div id="documentsContainer">
                <div class="loading">Loading documents...</div>
            </div>
        </div>

        <div class="dashboard-section">
            <h2 class="section-title">Page Visit Analytics</h2>
            <div id="page-visits-container">
                <div class="loading">Loading page visit data...</div>
            </div>
        </div>

        <div class="dashboard-section">
            <h2 class="section-title">AI Interaction Analytics</h2>
            <div id="ai-interactions-container">
                <div class="loading">Loading AI interaction data...</div>
            </div>
        </div>


        <div class="dashboard-section">
            <h2 class="section-title">Model Deployments</h2>
            <p class="section-description" style="color: rgba(255, 255, 255, 0.7); margin-bottom: 1.5rem; font-size: 0.9rem;">
                Models are automatically approved and deployed after passing 6 quality validation checks.
                <br><strong style="color: rgba(0, 210, 140, 0.9);">No manual approval needed - the system ensures quality automatically.</strong>
            </p>
            <div id="deployment-history-container">
                <div class="loading">Loading deployment history...</div>
            </div>
        </div>

        <div class="dashboard-section">
            <h2 class="section-title">Advanced Learning System</h2>
            <div class="learning-insights" id="learningInsights">
                <div class="insight-item">
                    <span class="insight-label">Learning Status:</span>
                    <span class="insight-value" id="learningStatus">Loading...</span>
                </div>
                <div class="insight-item">
                    <span class="insight-label">Total Documents:</span>
                    <span class="insight-value" id="totalDocuments">Loading...</span>
                </div>
                <div class="insight-item">
                    <span class="insight-label">Success Rate:</span>
                    <span class="insight-value" id="successRate">Loading...</span>
                </div>
                <div class="insight-item">
                    <span class="insight-label">User Satisfaction:</span>
                    <span class="insight-value" id="userSatisfaction">Loading...</span>
                </div>
                <div class="insight-item">
                    <span class="insight-label">Features Enabled:</span>
                    <span class="insight-value" id="featuresEnabled">Loading...</span>
                </div>
                <button class="refresh-btn" id="refreshLearningBtn">Refresh Insights</button>
            </div>
        </div>

        <div class="dashboard-section">
            <h2 class="section-title">Epsilon AI Learning Analytics</h2>
            <div id="epsilon-learning-container">
                <div class="loading">Loading Epsilon AI learning analytics...</div>
            </div>
        </div>
    </div>

    <div id="userModal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close" id="modalCloseBtn">×</button>
            <h2 style="margin-bottom: 1rem; color: var(--neural-text);">User Management</h2>
            <div id="userModalContent">
                <div class="loading">Loading users...</div>
            </div>
        </div>
    </div>

    <script>
        let selectedFiles = [];
        let isInitialized = false;
        const documentsState = {
            list: [],
            selectedId: null
        };

        function toggleMobileMenu() {
            const mobileMenu = document.getElementById('mobileMenu');
            const menuBtn = document.getElementById('mobileMenuBtn');
            if (!mobileMenu || !menuBtn) return;

            const isActive = mobileMenu.classList.toggle('active');
            menuBtn.classList.toggle('active', isActive);
            document.body.classList.toggle('menu-open', isActive);
        }
        
        // Attach to window for global access
        window.toggleMobileMenu = toggleMobileMenu;

        function toggleOwnerDropdown() {
            const dropdown = document.getElementById('ownerDropdown');
            if (dropdown) {
                dropdown.classList.toggle('show');
            }
        }
        
        // Attach to window for global access
        window.toggleOwnerDropdown = toggleOwnerDropdown;

        // Close dropdown when clicking outside
        function toggleOwnerDropdown() {
            const dropdown = document.getElementById('ownerDropdown');
            if (dropdown) {
                dropdown.classList.toggle('active');
            }
        }
        
        window.toggleOwnerDropdown = toggleOwnerDropdown;
        
        document.addEventListener('click', function(e) {
            const profileCircle = document.getElementById('ownerProfileCircle');
            const dropdown = document.getElementById('ownerDropdown');
            if (profileCircle && dropdown && !profileCircle.contains(e.target) && !dropdown.contains(e.target)) {
                dropdown.classList.remove('active');
            }
        });

        let cachedNavUser = null;

        function getStoredUser() {
            try {
                // Safety check: validate localStorage data
                const raw = localStorage.getItem('epsilon_user');
                if (!raw || typeof raw !== 'string' || raw.length > 10000) {
                    return null;
                }
                const parsed = JSON.parse(raw);
                // Validate parsed object structure
                if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
                    return parsed;
                }
                return null;
            } catch (err) {
                console.warn('Unable to parse stored user:', err);
                return null;
            }
        }

        function computeInitials(source) {
            // Safety check: validate input
            if (!source || typeof source !== 'string') return 'U';
            if (source.length > 200) return 'U'; // DoS protection
            const tokens = source.trim().split(/\s+/).filter(Boolean);
            if (!tokens.length) return source.charAt(0).toUpperCase();
            return tokens.slice(0, 2).map(part => part.charAt(0)).join('').toUpperCase();
        }

        function updateNavForWidth(user) {
            const contactBtn = document.getElementById('contactBtn');
            if (contactBtn) {
                if (user && window.innerWidth <= 1240) {
                    contactBtn.style.display = 'none';
                } else {
                    contactBtn.style.display = 'inline-flex';
                }
            }
        }

        function renderNavUser(user) {
            const profilePill = document.getElementById('profilePill');
            const loginStatus = document.getElementById('loginStatus');
            const statusUser = document.getElementById('statusUser');
            const statusInitials = document.getElementById('statusInitials');
            const statusLogout = document.getElementById('statusLogout');
            
            if (user && user.email && profilePill && statusUser && statusLogout) {
                const displayName = (user.name || user.full_name || '').trim() || user.email.split('@')[0];
                statusUser.textContent = displayName;
                if (statusInitials) {
                    statusInitials.textContent = computeInitials(displayName || user.email);
                }

                profilePill.style.display = 'flex';
                profilePill.onclick = () => window.location.href = '/edit_profile';

                if (loginStatus) {
                    loginStatus.style.display = 'flex';
                }
                
                statusLogout.onclick = (e) => {
                    e.preventDefault();
                    localStorage.removeItem('epsilon_user');
                    window.location.reload();
                };
            } else {
                if (profilePill) profilePill.style.display = 'none';
                if (loginStatus) loginStatus.style.display = 'none';
            }

            updateNavForWidth(user);
        }

        function syncNavUserState() {
            cachedNavUser = getStoredUser();
            renderNavUser(cachedNavUser);
        }

        // Performance: Debounce resize handler
        let resizeTimeout;
        function debouncedResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                updateNavForWidth(cachedNavUser);
            }, 150);
        }

        // Initialize login status handling
        syncNavUserState();
        window.addEventListener('resize', debouncedResize, { passive: true });

        function setActiveNavLink() {
            const path = window.location.pathname.replace(/index\.html$/i, '').replace(/\/$/, '') || '/';
            const navLinks = document.querySelectorAll('.nav-link');
            navLinks.forEach(link => {
                const target = link.getAttribute('href');
                if (target === path || (target === '/' && path === '/')) {
                    link.classList.add('active');
                }
            });
        }

        async function initOwnerProfileBubble() {
            const user = getStoredUser();
            const profileCircle = document.getElementById('ownerProfileCircle');
            const ownerInitials = document.getElementById('ownerInitials');
            const ownerLink = document.getElementById('ownerLink');
            
            if (!user) {
                if (profileCircle) {
                    profileCircle.style.display = 'none';
                    profileCircle.style.visibility = 'hidden';
                }
                return;
            }
            
            // Fetch latest user profile from server to get the most current role and avatar
            let serverUser = user;
            try {
                const response = await fetch('/api/profile/me', {
                    method: 'GET',
                    credentials: 'include'
                });
                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.profile) {
                        serverUser = result.profile;
                        // Update localStorage with the latest user data from the server
                        localStorage.setItem('epsilon_user', JSON.stringify(serverUser));
                    }
                }
            } catch (error) {
                console.warn('Failed to refresh user profile from server for owner bubble:', error.message);
            }
            
            // Show profile circle
            if (profileCircle) {
                profileCircle.style.display = 'flex';
                profileCircle.style.visibility = 'visible';
                profileCircle.style.opacity = '1';
                profileCircle.style.pointerEvents = 'auto';
                
                // Display avatar if available
                if (serverUser.avatar_url && serverUser.avatar_url.startsWith('data:image/')) {
                    profileCircle.style.backgroundImage = 'url(' + serverUser.avatar_url + ')';
                    profileCircle.style.backgroundSize = 'cover';
                    profileCircle.style.backgroundPosition = 'center';
                    profileCircle.style.backgroundColor = '';
                    profileCircle.style.backgroundRepeat = 'no-repeat';
                    if (ownerInitials) {
                        ownerInitials.style.display = 'none';
                        ownerInitials.style.visibility = 'hidden';
                    }
                } else {
                    profileCircle.style.backgroundImage = 'none';
                    const colors = ['#F97316', '#FF8A3D', '#EA580C', '#C2410C', '#F97316', '#FF8A3D', '#EA580C'];
                    const randomColor = colors[Math.floor(Math.random() * colors.length)];
                    profileCircle.style.backgroundColor = randomColor;
                    profileCircle.style.background = randomColor;
                    if (ownerInitials) {
                        ownerInitials.style.display = 'flex';
                        ownerInitials.style.visibility = 'visible';
                        const displayName = (serverUser.name || serverUser.full_name || serverUser.email || 'O');
                        ownerInitials.textContent = displayName.charAt(0).toUpperCase();
                    }
                }
            }
            
            // Show/hide owner link based on role
            if (ownerLink) {
                // Use serverUser role if available (most up-to-date), otherwise use user.role
                const currentRole = (serverUser && serverUser.role) ? serverUser.role : (user.role || 'client');
                if (currentRole === 'owner') {
                    ownerLink.style.display = 'block';
                } else {
                    ownerLink.style.display = 'none';
                }
            }
        }

        async function loadOwnerProfile() {
            try {
                const response = await fetch('/api/profile/me', {
                    method: 'GET',
                    credentials: 'include'
                });

                if (!response.ok) {
                    throw new Error('Profile fetch failed');
                }

                const result = await response.json();
                const profile = result.profile || {};

                if (profile.full_name) {
                    const profileName = document.getElementById('profileName');
                    if (profileName) {
                        profileName.textContent = profile.full_name.split(' ')[0] || 'Account';
                    }
                    const welcomeEl = document.getElementById('user-welcome');
                    if (welcomeEl) {
                        welcomeEl.textContent = `Welcome, ${profile.full_name.split(' ')[0]}!`;
                    }
                }

                if (result.epsilonVersion) {
                    const versionLabel = document.getElementById('epsilonVersionLabel');
                    if (versionLabel) {
                        versionLabel.textContent = result.epsilonVersion;
                    }
                }
                
                // Update avatar if available
                if (profile.avatar_url) {
                    const userStr = localStorage.getItem('epsilon_user');
                    if (userStr) {
                        try {
                            const user = JSON.parse(userStr);
                            user.avatar = profile.avatar_url;
                            user.avatar_url = profile.avatar_url;
                            localStorage.setItem('epsilon_user', JSON.stringify(user));
                            // Refresh profile bubble to show avatar
                            initOwnerProfileBubble();
                        } catch (e) {
                            console.warn('Could not update avatar in localStorage:', e);
                        }
                    }
                }
            } catch (error) {
                console.warn('Could not load profile metadata:', error.message);
            }
        }

        // Get CSRF token from cookie (preferred) or fetch from server
        async function getCsrfToken() {
            // First try to get from cookie (most reliable)
            const cookieToken = getCsrfTokenFromCookie();
            if (cookieToken) {
                return cookieToken;
            }
            
            // If no cookie token, fetch from server
            try {
                const response = await fetch('/api/csrf-token', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    // Store in localStorage as backup, but prefer cookie
                    localStorage.setItem('csrfToken', data.token);
                    return data.token;
                }
            } catch (error) {
                console.error('Error getting CSRF token:', error);
            }
            
            // Last resort: use localStorage if available
            const storedToken = localStorage.getItem('csrfToken');
            if (storedToken) {
                return storedToken;
            }
            
            return null;
        }

        // Get CSRF token from cookie (primary method)
        function getCsrfTokenFromCookie() {
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'csrfToken') {
                    return value;
                }
            }
            return null;
        }
        
        // Helper to get CSRF token for requests (always prefer cookie)
        function getCsrfTokenForRequest() {
            return getCsrfTokenFromCookie() || localStorage.getItem('csrfToken') || '';
        }

        function updateConnectionStatus(status, message) {
            const statusEl = document.getElementById('connectionStatus');
            statusEl.className = `connection-status ${status}`;
            statusEl.textContent = message;
        }

        async function initializeDashboard() {
            if (isInitialized) return;
            
            // Check auth FIRST before showing anything
            try {
                if (!(await checkAuth())) {
                    // Auth failed - content already hidden by checkAuth
                    updateConnectionStatus('disconnected', 'Authentication failed');
                    return;
                }
            } catch (error) {
                // Auth check threw error - hide content and redirect
                const dashboardContainer = document.querySelector('.dashboard-container');
                if (dashboardContainer) {
                    dashboardContainer.style.display = 'none';
                }
                redirectToLogin();
                return;
            }
            
            // Only proceed if auth passed
            updateConnectionStatus('loading', 'Initializing...');
            
            try {

                await getCsrfToken();
                await testConnection();
                updateConnectionStatus('connected', 'Connected');

                // Load critical data first (visible above fold)
                await Promise.all([
                    loadAnalytics(),
                    loadLearningMetrics()
                ]);
                
                // Load non-critical data after initial render (below fold)
                requestIdleCallback ? requestIdleCallback(() => {
                    Promise.all([
                        loadDocuments(),
                        loadEpsilonLearning()
                    ]).catch(err => console.warn('[OWNER] Non-critical data load failed:', err));
                }) : setTimeout(() => {
                    Promise.all([
                        loadDocuments(),
                        loadEpsilonLearning()
                    ]).catch(err => console.warn('[OWNER] Non-critical data load failed:', err));
                }, 200);

                isInitialized = true;
                
                setTimeout(() => {
                    const statusEl = document.getElementById('connectionStatus');
                    statusEl.style.opacity = '0';
                    setTimeout(() => statusEl.style.display = 'none', 300);
                }, 2000);
                
            } catch (error) {
                console.error('[OWNER] Dashboard initialization failed:', error);
                updateConnectionStatus('disconnected', 'Connection failed');
                
                if (error.message && (error.message.includes('Authentication failed') || error.message.includes('Access denied'))) {
                    console.error('Your session has expired or you do not have owner permissions. Please log in again.');
                    redirectToLogin();
                }
            }
        }

                async function testConnection() {
            try {
                // Try a simpler health check first - profile endpoint
                const profileResponse = await fetch('/api/profile/me', {
                    method: 'GET',
                    headers: { 
                        'Accept': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include',
                    signal: AbortSignal.timeout(5000) // 5 second timeout
                });

                if (profileResponse.ok) {
                    return true; // Connection works
                }

                // Fallback: try analytics endpoint
                const response = await fetch('/api/analytics', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include',
                    body: JSON.stringify({ action: 'get-analytics' }),
                    signal: AbortSignal.timeout(5000) // 5 second timeout
                });

                if (!response.ok) {
                    if (response.status === 403 || response.status === 401) {
                        throw new Error('Access denied - check authentication');
                    }
                    throw new Error(`Server error: ${response.status}`);
                }

                return true;
            } catch (error) {
                if (error.name === 'AbortError' || error.name === 'TimeoutError') {
                    throw new Error('Connection timeout - server may be slow');
                }
                console.error('[OWNER] Connection test failed:', error.message);
                throw error;
            }
        }

        async function checkAuth() {
            let user = null;
            let userStr = localStorage.getItem('epsilon_user');
            
            if (userStr && typeof userStr === 'string' && userStr.length <= 10000) {
                try {
                    user = JSON.parse(userStr);
                    if (!user || typeof user !== 'object' || Array.isArray(user)) {
                        user = null;
                    }
                    if (user && user.email && (typeof user.email !== 'string' || user.email.length > 255)) {
                        user = null;
                    }
                    if (user && user.name && (typeof user.name !== 'string' || user.name.length > 200)) {
                        user = null;
                    }
                } catch (error) {
                    user = null;
                }
            }
            
            let serverRole = null;
            let serverAvatar = null;
            
            try {
                const response = await fetch('/api/profile/me', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const profileResult = await response.json();
                    
                    if (profileResult?.profile?.role) {
                        serverRole = profileResult.profile.role;
                        serverAvatar = profileResult.profile.avatar_url || null;
                        
                        if (!user) {
                            user = {
                                id: profileResult.profile.id || null,
                                email: profileResult.profile.email || null,
                                name: profileResult.profile.name || null,
                                role: serverRole,
                                avatar_url: serverAvatar,
                                avatar: serverAvatar
                            };
                        } else {
                            user.role = serverRole;
                            if (serverAvatar) {
                                user.avatar_url = serverAvatar;
                                user.avatar = serverAvatar;
                            }
                        }
                        localStorage.setItem('epsilon_user', JSON.stringify(user));
                    } else if (profileResult?.profile) {
                        if (!user) {
                            user = {
                                id: profileResult.profile.id || null,
                                email: profileResult.profile.email || null,
                                name: profileResult.profile.name || null,
                                role: profileResult.profile.role || 'client',
                                avatar_url: profileResult.profile.avatar_url || null,
                                avatar: profileResult.profile.avatar_url || null
                            };
                        } else {
                            if (profileResult.profile.avatar_url) {
                                user.avatar_url = profileResult.profile.avatar_url;
                                user.avatar = profileResult.profile.avatar_url;
                            }
                            if (!user.role && profileResult.profile.role) {
                                user.role = profileResult.profile.role;
                            }
                        }
                        localStorage.setItem('epsilon_user', JSON.stringify(user));
                        serverRole = user.role;
                        serverAvatar = user.avatar_url;
                    }
                }
            } catch (error) {
                console.warn('[OWNER] Failed to fetch profile from server:', error.message);
            }
            
            const finalRole = serverRole || (user && user.role) || 'client';
            
            if (finalRole !== 'owner') {
                console.warn('[OWNER] Client-side role check failed, but server already verified access by serving this page');
            }
            
            const dashboardContainer = document.querySelector('.dashboard-container');
            if (dashboardContainer) {
                dashboardContainer.style.display = 'flex';
            }
            
            if (user) {
                const welcomeEl = document.getElementById('user-welcome');
                if (welcomeEl) {
                    const displayName = (user.name || user.email || '').substring(0, 100);
                    welcomeEl.textContent = `Welcome, ${displayName}`;
                }
                
                const ownerDropdownName = document.getElementById('ownerDropdownName');
                if (ownerDropdownName) {
                    const displayName = user.email ? user.email.split('@')[0] : (user.name || 'Owner');
                    ownerDropdownName.textContent = displayName;
                }
                
                const profileNameEl = document.getElementById('profileName');
                if (profileNameEl) {
                    const displayName = (user.name || user.email || 'Account').substring(0, 100);
                    profileNameEl.textContent = displayName;
                }
            }
            
            return true;
        }

        function redirectToLogin() {
            // Don't redirect if we're already on login page
            if (window.location.pathname === '/login' || window.location.pathname === '/login.html') {
                return;
            }
            window.location.href = '/login?permission=false';
        }

        function logout() {
            localStorage.removeItem('epsilon_user');
            
            // Clear the auth cookie by calling the logout endpoint
            fetch('/api/auth', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': localStorage.getItem('csrfToken') || ''
                },
                credentials: 'include',
                body: JSON.stringify({ action: 'logout' })
            }).catch(error => {
            }).finally(() => {
                window.location.href = '/';
            });
        }

        async function loadAnalytics() {
            const refreshBtn = document.getElementById('refreshBtn');
            const statsContainer = document.getElementById('stats-container');
            
            try {
                refreshBtn.disabled = true;
                refreshBtn.textContent = 'Loading...';

                // Load analytics data (removed mock data: estimates, conversions)
                const [analyticsResponse, pageVisitsResponse, aiInteractionsResponse] = await Promise.all([
                    fetch('/api/analytics', {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Accept': 'application/json',
                            'X-CSRF-Token': getCsrfTokenForRequest()
                        },
                        credentials: 'include',
                        body: JSON.stringify({ action: 'get-analytics' })
                    }).catch(() => {
                        console.warn('Analytics endpoint failed, returning empty data');
                        return { ok: true, json: async () => ({ success: true, analytics: [] }) };
                    }),
                    fetch('/api/analytics', {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Accept': 'application/json',
                            'X-CSRF-Token': getCsrfTokenForRequest()
                        },
                        credentials: 'include',
                        body: JSON.stringify({ action: 'get-page-visits' })
                    }).catch(() => {
                        console.warn('Page visits endpoint failed, returning empty data');
                        return { ok: true, json: async () => ({ success: true, page_visits: [] }) };
                    }),
                    fetch('/api/analytics', {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Accept': 'application/json',
                            'X-CSRF-Token': getCsrfTokenForRequest()
                        },
                        credentials: 'include',
                        body: JSON.stringify({ action: 'get-ai-interactions' })
                    }).catch(() => {
                        console.warn('AI interactions endpoint failed, returning empty data');
                        return { ok: true, json: async () => ({ success: true, ai_interactions: [] }) };
                    })
                ]);

                // Check all responses
                const responses = [analyticsResponse, pageVisitsResponse, aiInteractionsResponse];
                for (const response of responses) {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                }

                // Parse all data
                const [analyticsData, pageVisitsData, aiInteractionsData] = await Promise.all(
                    responses.map(r => r.json())
                );

                
                // Display main analytics
                displayAnalytics(analyticsData);
                
                // Display additional analytics sections
                displayPageVisits(pageVisitsData);
                displayAIInteractions(aiInteractionsData);
                
                updateConnectionStatus('connected', 'Data updated');
                
            } catch (error) {
                console.error('[OWNER] Error loading analytics:', error);
                showError('Failed to load analytics: ' + error.message);
                updateConnectionStatus('disconnected', 'Update failed');
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.textContent = 'Refresh Data';
            }
        }

        function displayAnalytics(data) {
            
            const statsHtml = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <span class="stat-number">${data.totalUsers || 0}</span>
                        <span class="stat-label">Total Users</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">${data.conversations || 0}</span>
                        <span class="stat-label">Total Conversations</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">${data.activeUsers || 0}</span>
                        <span class="stat-label">Active Users (24h)</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">${data.userSatisfaction || 0}/5</span>
                        <span class="stat-label">User Satisfaction</span>
                    </div>
                </div>
            `;
            const container = document.getElementById('stats-container');
            if (container) {
                container.textContent = ''; // Clear first
                container.insertAdjacentHTML('afterbegin', statsHtml); // Use insertAdjacentHTML instead of innerHTML
            }
        }

        function displayPageVisits(data) {
            
            const container = document.getElementById('page-visits-container');
            if (!container) return;
            
            if (!data || (data.totalVisits === 0 && (!data.topPages || data.topPages.length === 0))) {
                container.textContent = '';
                container.insertAdjacentHTML('afterbegin', `
                    <div style="padding: 2rem; text-align: center; color: var(--neural-text-secondary);">
                        <p>No page visit data available yet.</p>
                        <p style="font-size: 0.9rem; margin-top: 0.5rem;">Page visits will appear here once users start browsing the site.</p>
                    </div>
                `);
                return;
            }
            
            const html = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <span class="stat-number">${data.totalVisits || 0}</span>
                        <span class="stat-label">Total Page Visits</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">${data.uniqueVisitors || 0}</span>
                        <span class="stat-label">Unique Visitors</span>
                    </div>
                </div>
                <div style="margin-top: 1rem;">
                    <h4 style="color: var(--neural-text); margin-bottom: 1rem;">Top Pages</h4>
                    ${(data.topPages && data.topPages.length > 0) ? `
                    <table class="analytics-table">
                        <thead>
                            <tr><th>Page</th><th>Visits</th><th>Unique Visitors</th></tr>
                        </thead>
                        <tbody>
                                ${data.topPages.map(page => `
                                <tr>
                                    <td>${escapeHtml(page.page)}</td>
                                    <td>${page.visits}</td>
                                    <td>${page.uniqueVisitors}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                    ` : '<p style="color: var(--neural-text-secondary);">No page visit data available.</p>'}
                </div>
            `;
            container.textContent = ''; // Clear first for security
            container.insertAdjacentHTML('afterbegin', html);
        }

        function displayAIInteractions(data) {
            
            const container = document.getElementById('ai-interactions-container');
            if (!container) return;
            
            if (!data || (data.totalInteractions === 0 && (!data.topIntents || data.topIntents.length === 0))) {
                container.textContent = '';
                container.insertAdjacentHTML('afterbegin', `
                    <div style="padding: 2rem; text-align: center; color: var(--neural-text-secondary);">
                        <p>No AI interaction data available yet.</p>
                        <p style="font-size: 0.9rem; margin-top: 0.5rem;">Interactions will appear here once users start chatting with Epsilon AI.</p>
                    </div>
                `);
                return;
            }
            
            const html = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <span class="stat-number">${data.totalInteractions || 0}</span>
                        <span class="stat-label">Total Interactions</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">${data.averageSatisfaction || 0}/5</span>
                        <span class="stat-label">Avg Satisfaction</span>
                    </div>
                </div>
                <div style="margin-top: 1rem;">
                    <h4 style="color: var(--neural-text); margin-bottom: 1rem;">Top Intents</h4>
                    ${(data.topIntents && data.topIntents.length > 0) ? `
                    <table class="analytics-table">
                        <thead>
                            <tr><th>Intent</th><th>Count</th></tr>
                        </thead>
                        <tbody>
                                ${data.topIntents.map(intent => `
                                <tr>
                                    <td>${escapeHtml(intent.intent)}</td>
                                    <td>${intent.count}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                    ` : '<p style="color: var(--neural-text-secondary);">No intent data available.</p>'}
                </div>
            `;
            container.textContent = ''; // Clear first for security
            container.insertAdjacentHTML('afterbegin', html);
        }


        function showError(message) {
            const container = document.getElementById('stats-container');
            // SECURITY: Use textContent instead of innerHTML, or properly sanitize HTML
            container.textContent = '';
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            container.appendChild(errorDiv);
        }

        async function viewUsers() {
            const modal = document.getElementById('userModal');
            const content = document.getElementById('userModalContent');
            
            modal.classList.add('active');
            content.textContent = '';
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading';
            loadingDiv.textContent = 'Loading users...';
            content.appendChild(loadingDiv);
            
            try {
                // FIXED: Removed token from localStorage.
                const response = await fetch('/api/analytics', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include',
                    body: JSON.stringify({ action: 'get-users' })
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                
                if (data.users && data.users.length > 0) {
                    const tableHtml = `
                        <table class="analytics-table">
                            <thead><tr><th>Name</th><th>Email</th><th>Last Active</th><th>Role</th></tr></thead>
                            <tbody>
                                ${data.users.map(user => `
                                    <tr>
                                        <td>${escapeHtml(user.name || 'N/A')}</td>
                                        <td>${escapeHtml(user.email || 'N/A')}</td>
                                        <td>${formatDate(user.lastActive)}</td>
                                        <td><span style="color: ${user.role === 'owner' ? 'var(--flame-core)' : 'var(--neural-muted)'}">${escapeHtml(user.role || 'client')}</span></td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>`;
                    content.textContent = '';
                    content.insertAdjacentHTML('afterbegin', tableHtml); // SAFE: tableHtml is from controlled API
                } else {
                    content.textContent = '';
                    const noUsersDiv = document.createElement('div');
                    noUsersDiv.className = 'loading';
                    noUsersDiv.textContent = 'No users found';
                    content.appendChild(noUsersDiv);
                }
                
            } catch (error) {
                content.textContent = '';
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = 'Failed to load users: ' + error.message;
                content.appendChild(errorDiv);
            }
        }

        function closeModal() {
            document.getElementById('userModal').classList.remove('active');
        }

        async function downloadAnalytics() {
            // This function is client-side and doesn't need auth changes, but ensure it calls loadAnalytics correctly.
        }

        function handleFileSelect(event) {
            // Safety check: validate event and files
            if (!event || !event.target || !event.target.files) {
                console.error('Invalid file select event');
                return;
            }
            const files = Array.from(event.target.files);
            // DoS protection: limit number of files
            if (files.length > 50) {
                alert('Too many files selected. Maximum 50 files allowed.');
                return;
            }
            // Validate file sizes (DoS protection)
            const maxFileSize = 7.5 * 1024 * 1024 * 1024; // 7.5GB (3x 2.4GB requirement)
            for (const file of files) {
                if (file.size > maxFileSize) {
                    alert(`File "${file.name}" is too large. Maximum size is 7.5GB.`);
                    return;
                }
                // Validate file name length
                if (file.name.length > 500) {
                    alert(`File name "${file.name.substring(0, 50)}..." is too long.`);
                    return;
                }
            }
            selectedFiles = files;
            updateUploadButton();
        }

        function updateUploadButton() {
            const uploadBtn = document.getElementById('uploadBtn');
            const learningCategory = document.getElementById('learningCategory').value;
            const docType = document.getElementById('docType').value;
            
            const canUpload = selectedFiles.length > 0 && learningCategory && docType;
            uploadBtn.disabled = !canUpload;
            
            if (selectedFiles.length === 0) {
                uploadBtn.textContent = 'Upload & Start Learning';
            } else if (!learningCategory || !docType) {
                uploadBtn.textContent = 'Complete Form to Upload';
            } else {
                uploadBtn.textContent = `Upload & Learn from ${selectedFiles.length} Document${selectedFiles.length > 1 ? 's' : ''}`;
            }
        }

        // Upload document to API
        async function uploadDocumentToAPI(file, docType, learningCategory, description, tags, onProgress) {
            // Safety check: validate inputs
            if (!file || !(file instanceof File)) {
                throw new Error('Invalid file object');
            }
            if (file.size > 7.5 * 1024 * 1024 * 1024) { // 7.5GB limit (3x 2.4GB requirement)
                throw new Error('File size exceeds 7.5GB limit');
            }
            if (file.name.length > 500) {
                throw new Error('File name too long');
            }
            if (!docType || typeof docType !== 'string' || docType.length > 100) {
                throw new Error('Invalid document type');
            }
            if (!learningCategory || typeof learningCategory !== 'string' || learningCategory.length > 100) {
                throw new Error('Invalid learning category');
            }
            if (description && (typeof description !== 'string' || description.length > 5000)) {
                throw new Error('Description too long (max 5000 characters)');
            }
            if (tags && (!Array.isArray(tags) || tags.length > 50)) {
                throw new Error('Invalid tags (max 50 tags)');
            }
            // Validate tag content
            if (tags) {
                for (const tag of tags) {
                    if (typeof tag !== 'string' || tag.length > 100) {
                        throw new Error('Invalid tag format');
                    }
                }
            }
            
            try {
                // Get CSRF token from server (returns the cookie token to ensure match)
                const tokenResponse = await fetch('/api/csrf-token', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                if (!tokenResponse.ok) {
                    throw new Error('Failed to get CSRF token');
                }
                
                const { token } = await tokenResponse.json();
                
                // Validate token
                if (!token || typeof token !== 'string' || token.length > 500) {
                    throw new Error('Invalid CSRF token received');
                }
                
                // Use the token from the API response (which matches the cookie)
                // Store it in localStorage for future use
                localStorage.setItem('csrfToken', token);
                const csrfToken = token;
                
                // Create FormData
                const formData = new FormData();
                formData.append('file', file);
                formData.append('document_type', docType);
                formData.append('learning_category', learningCategory);
                if (description) {
                    formData.append('description', description);
                }
                if (tags && tags.length > 0) {
                    formData.append('tags', JSON.stringify(tags));
                }
                if (csrfToken) {
                    formData.append('_csrf', csrfToken);
                }
                
                // Use XMLHttpRequest for progress tracking
                return new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    const startTime = Date.now();
                    let lastLoaded = 0;
                    let lastTime = startTime;
                    
                    // Track upload progress
                    xhr.upload.addEventListener('progress', (e) => {
                        if (e.lengthComputable && onProgress) {
                            const percent = Math.round((e.loaded / e.total) * 100);
                            const currentTime = Date.now();
                            const elapsed = (currentTime - startTime) / 1000; // seconds
                            
                            // Calculate speed (bytes per second)
                            const speed = e.loaded / elapsed;
                            
                            // Calculate time remaining
                            const remaining = e.total - e.loaded;
                            const timeRemaining = remaining / speed; // seconds
                            
                            // Format time remaining
                            let timeText = 'Calculating...';
                            if (timeRemaining > 0 && isFinite(timeRemaining)) {
                                if (timeRemaining < 60) {
                                    timeText = `${Math.round(timeRemaining)}s remaining`;
                                } else if (timeRemaining < 3600) {
                                    const minutes = Math.floor(timeRemaining / 60);
                                    const seconds = Math.round(timeRemaining % 60);
                                    timeText = `${minutes}m ${seconds}s remaining`;
                                } else {
                                    const hours = Math.floor(timeRemaining / 3600);
                                    const minutes = Math.floor((timeRemaining % 3600) / 60);
                                    timeText = `${hours}h ${minutes}m remaining`;
                                }
                            }
                            
                            // Format speed
                            let speedText = '';
                            if (speed > 0 && isFinite(speed)) {
                                if (speed < 1024) {
                                    speedText = `${Math.round(speed)} B/s`;
                                } else if (speed < 1024 * 1024) {
                                    speedText = `${(speed / 1024).toFixed(1)} KB/s`;
                                } else {
                                    speedText = `${(speed / (1024 * 1024)).toFixed(1)} MB/s`;
                                }
                            }
                            
                            onProgress({
                                percent: percent,
                                loaded: e.loaded,
                                total: e.total,
                                timeRemaining: timeRemaining,
                                timeText: timeText,
                                speed: speed,
                                speedText: speedText
                            });
                        }
                    });
                    
                    xhr.addEventListener('load', () => {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            try {
                                const result = JSON.parse(xhr.responseText);
                                resolve({
                    success: true,
                    document_id: result.document_id,
                    message: result.message || 'Upload successful'
                                });
                            } catch (parseError) {
                                reject(new Error('Invalid response from server'));
                            }
                        } else {
                            try {
                                const errorData = JSON.parse(xhr.responseText);
                                resolve({
                                    success: false,
                                    message: errorData.error || `Upload failed with status ${xhr.status}`
                                });
                            } catch (parseError) {
                                resolve({
                                    success: false,
                                    message: `Upload failed with status ${xhr.status}`
                                });
                            }
                        }
                    });
                    
                    xhr.addEventListener('error', () => {
                        reject(new Error('Network error during upload'));
                    });
                    
                    xhr.addEventListener('abort', () => {
                        reject(new Error('Upload was cancelled or connection was interrupted. Please try again.'));
                    });
                    
                    // No client-side timeout - let uploads complete naturally
                    // Server will handle the upload and respond when done
                    // Progress tracking will continue until completion
                    
                    // Open and send request
                    xhr.open('POST', '/api/upload-document');
                    xhr.setRequestHeader('X-CSRF-Token', csrfToken);
                    xhr.withCredentials = true;
                    xhr.send(formData);
                });
                
            } catch (error) {
                console.error('Upload error:', error);
                let errorMessage = error.message || 'Upload failed';
                return {
                    success: false,
                    message: errorMessage
                };
            }
        }

        async function uploadToTraditionalSystem(file, docType) {
            try {
                // Get fresh CSRF token
                const tokenResponse = await fetch('/api/csrf-token', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                if (!tokenResponse.ok) {
                    console.warn(`[OWNER] CSRF token fetch failed, skipping backup upload: ${file.name}`);
                    return;
                }
                
                const { token } = await tokenResponse.json();
                
                const formData = new FormData();
                formData.append('file', file);
                formData.append('document_type', docType);
                
                const response = await fetch('/api/upload-document', {
                    method: 'POST',
                    headers: {
                       'X-CSRF-Token': token
                    },
                    credentials: 'include',
                    body: formData
                });
                
                if (response.ok) {
                } else {
                    // Silently handle CSRF errors for backup upload - main upload is working
                }
            } catch (error) {
                // Silently handle errors for backup upload - main upload is working
                console.log(`Backup upload skipped (main upload successful): ${file.name}`);
            }
        }

        function initializeDragAndDrop() {
            const uploadArea = document.getElementById('uploadArea');
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, e => { e.preventDefault(); e.stopPropagation(); }, false);
            });
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => uploadArea.classList.add('dragover'), false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragover'), false);
            });
            uploadArea.addEventListener('drop', e => {
                // Safety check: validate event and files
                if (!e || !e.dataTransfer || !e.dataTransfer.files) {
                    console.error('Invalid drop event');
                    return;
                }
                const files = Array.from(e.dataTransfer.files);
                // DoS protection: limit number of files
                if (files.length > 50) {
                    alert('Too many files selected. Maximum 50 files allowed.');
                    return;
                }
                // Validate file sizes (DoS protection)
                const maxFileSize = 7.5 * 1024 * 1024 * 1024; // 7.5GB (3x 2.4GB requirement)
                for (const file of files) {
                    if (file.size > maxFileSize) {
                        alert(`File "${file.name}" is too large. Maximum size is 7.5GB.`);
                        return;
                    }
                    // Validate file name length
                    if (file.name.length > 500) {
                        alert(`File name "${file.name.substring(0, 50)}..." is too long.`);
                        return;
                    }
                }
                selectedFiles = files;
                updateUploadButton();
            }, false);
        }

        async function uploadDocuments() {
            // Safety check: validate selectedFiles
            if (!selectedFiles || selectedFiles.length === 0) {
                alert('Please select at least one file to upload.');
                return;
            }
            // DoS protection: limit number of files
            if (selectedFiles.length > 50) {
                alert('Too many files selected. Maximum 50 files allowed.');
                return;
            }

            const docTypeEl = document.getElementById('docType');
            const learningCategoryEl = document.getElementById('learningCategory');
            const descriptionEl = document.getElementById('docDescription');
            const tagsEl = document.getElementById('docTags');
            
            if (!docTypeEl || !learningCategoryEl) {
                alert('Required form fields are missing.');
                return;
            }
            
            const docType = docTypeEl.value;
            const learningCategory = learningCategoryEl.value;
            const description = descriptionEl ? descriptionEl.value : '';
            const tags = tagsEl ? tagsEl.value.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
            
            // Safety check: validate form inputs
            if (!docType || typeof docType !== 'string' || docType.length > 100) {
                alert('Invalid document type selected.');
                return;
            }
            if (!learningCategory || typeof learningCategory !== 'string' || learningCategory.length > 100) {
                alert('Invalid learning category selected.');
                return;
            }
            if (description && (typeof description !== 'string' || description.length > 5000)) {
                alert('Description is too long (max 5000 characters).');
                return;
            }
            // Validate tags
            if (tags.length > 50) {
                alert('Too many tags (max 50).');
                return;
            }
            for (const tag of tags) {
                if (typeof tag !== 'string' || tag.length > 100) {
                    alert('Invalid tag format.');
                    return;
                }
            }
            
            const progressDiv = document.getElementById('uploadProgress');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const progressPercent = document.getElementById('progressPercent');
            const progressTime = document.getElementById('progressTime');
            
            // Validate required fields
            if (!learningCategory) {
                alert('Please select a learning category');
                return;
            }
            if (!docType) {
                alert('Please select a document type');
                return;
            }
            
            progressDiv.style.display = 'block';
            
            try {
                const totalFiles = selectedFiles.length;
                let totalSize = 0;
                let uploadedSize = 0;
                
                // Calculate total size
                for (const file of selectedFiles) {
                    totalSize += file.size;
                }
                
                for (let i = 0; i < selectedFiles.length; i++) {
                    const file = selectedFiles[i];
                    const fileStartSize = uploadedSize;
                    
                    // Upload document directly to our API with progress tracking
                    const uploadResult = await uploadDocumentToAPI(
                        file,
                        docType,
                        learningCategory,
                        description,
                        tags,
                        (progress) => {
                            // Calculate overall progress across all files
                            const fileProgress = (progress.loaded / progress.total) * file.size;
                            uploadedSize = fileStartSize + fileProgress;
                            const overallPercent = Math.round((uploadedSize / totalSize) * 100);
                            
                            // Update progress bar
                            progressFill.style.width = `${overallPercent}%`;
                            
                            // Update text
                            const filePercent = progress.percent;
                            const fileIndex = i + 1;
                            progressText.textContent = `Uploading ${file.name} (${fileIndex}/${totalFiles})...`;
                            
                            // Update percentage and time
                            if (progressPercent) {
                                progressPercent.textContent = `${filePercent}%`;
                            }
                            if (progressTime) {
                                progressTime.textContent = progress.timeText;
                            }
                        }
                    );
                    
                    uploadedSize = fileStartSize + file.size;
                    
                    if (uploadResult.success) {
                    } else {
                        console.error(`[OWNER] Document upload failed: ${file.name} - ${uploadResult.message}`);
                        alert(`Upload failed for ${file.name}: ${uploadResult.message}`);
                    }
                }
                
                progressFill.style.width = '100%';
                progressText.textContent = 'All documents uploaded and AI learning process started!';
                if (progressPercent) progressPercent.textContent = '100%';
                if (progressTime) progressTime.textContent = 'Complete';
                
                setTimeout(() => {
                    progressDiv.style.display = 'none';
                    selectedFiles = [];
                    updateUploadButton();
                    loadDocuments();
                    loadEpsilonLearning(); // Refresh Epsilon AI learning data
                }, 2000);
            } catch (error) {
                console.error('Upload error:', error);
                progressText.textContent = 'Upload failed: ' + error.message;
                if (progressTime) progressTime.textContent = 'Error';
            }
        }

        // Process uploaded document for Epsilon AI learning - ENHANCED BRAIN-LIKE LEARNING
        async function processDocumentForEpsilon(documentId, docType, fileName) {
            try {
                
                // First, get the document content for learning
                const documentContent = await getDocumentContent(documentId);
                
                // Extract learning data from the document
                const learningData = extractDocumentLearningData(documentContent, docType);
                
                // Store learning data in Supabase
                await storeDocumentLearningData(documentId, learningData);
                
                const response = await fetch('/api/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        action: 'process-document-for-epsilon',
                        data: {
                            document_id: documentId,
                            document_type: docType,
                            file_name: fileName,
                            learning_data: learningData
                        }
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Processing failed: ${response.statusText}`);
                }
                
                const result = await response.json();
                if (result.success) {
                } else {
                    console.warn(`[OWNER] Document processing warning: ${result.error}`);
                }
                
            } catch (error) {
                console.error(`[OWNER] Error processing document for Epsilon AI: ${error.message}`);
            }
        }

        // Get document content for learning
        async function getDocumentContent(documentId) {
            try {
                const response = await fetch('/api/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        action: 'get-document-content',
                        data: { document_id: documentId }
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    return result.content || '';
                }
                return '';
            } catch (error) {
                console.error('[OWNER] Error getting document content:', error);
                return '';
            }
        }

        // Extract learning data from document content - BRAIN-LIKE ANALYSIS
        function extractDocumentLearningData(content, documentType) {
            const learningData = {
                key_concepts: [],
                business_terms: [],
                processes: [],
                examples: [],
                best_practices: [],
                qa_pairs: []
            };

            // Extract key concepts
            learningData.key_concepts = extractKeyConcepts(content);
            
            // Extract business terms
            learningData.business_terms = extractBusinessTerms(content);
            
            // Extract processes and workflows
            learningData.processes = extractProcesses(content);
            
            // Extract examples
            learningData.examples = extractExamples(content);
            
            // Extract best practices
            learningData.best_practices = extractBestPractices(content);
            
            // Extract question-answer pairs
            learningData.qa_pairs = extractQuestionAnswerPairs(content);
            
            return learningData;
        }

        // Extract key concepts from content
        function extractKeyConcepts(content) {
            const concepts = [];
            const sentences = content.split(/[.!?]+/);
            
            sentences.forEach(sentence => {
                const trimmed = sentence.trim();
                if (trimmed.length > 20 && trimmed.length < 200) {
                    if (containsImportantConcept(trimmed)) {
                        concepts.push(trimmed);
                    }
                }
            });
            
            return concepts;
        }

        function containsImportantConcept(sentence) {
            const importantKeywords = [
                'automation', 'AI', 'artificial intelligence', 'process', 'workflow',
                'efficiency', 'optimization', 'integration', 'solution', 'strategy',
                'implementation', 'deployment', 'customization', 'scalability',
                'ROI', 'cost reduction', 'time saving', 'productivity'
            ];
            
            return importantKeywords.some(keyword => 
                sentence.toLowerCase().includes(keyword)
            );
        }

        // Extract business terms
        function extractBusinessTerms(content) {
            const businessTerms = [];
            const termPatterns = [
                /(?:cost|price|budget|investment|ROI|return on investment)/gi,
                /(?:efficiency|productivity|optimization|streamline)/gi,
                /(?:customer|client|user|stakeholder)/gi,
                /(?:process|workflow|procedure|methodology)/gi,
                /(?:technology|system|platform|tool)/gi
            ];
            
            termPatterns.forEach(pattern => {
                const matches = content.match(pattern);
                if (matches) {
                    businessTerms.push(...matches);
                }
            });
            
            return [...new Set(businessTerms)];
        }

        // Extract processes and workflows
        function extractProcesses(content) {
            const processes = [];
            const sentences = content.split(/[.!?]+/);
            let currentProcess = null;
            
            sentences.forEach(sentence => {
                const trimmed = sentence.trim();
                
                if (startsNewProcess(trimmed)) {
                    if (currentProcess) {
                        processes.push(currentProcess);
                    }
                    currentProcess = {
                        name: extractProcessName(trimmed),
                        steps: [trimmed]
                    };
                } else if (currentProcess && isProcessStep(trimmed)) {
                    currentProcess.steps.push(trimmed);
                }
            });
            
            if (currentProcess) {
                processes.push(currentProcess);
            }
            
            return processes;
        }

        function startsNewProcess(sentence) {
            return sentence.toLowerCase().includes('process') ||
                   sentence.toLowerCase().includes('workflow') ||
                   sentence.toLowerCase().includes('method') ||
                   sentence.toLowerCase().includes('approach');
        }

        function isProcessStep(sentence) {
            return sentence.toLowerCase().includes('step') ||
                   sentence.toLowerCase().includes('phase') ||
                   sentence.toLowerCase().includes('stage') ||
                   sentence.toLowerCase().includes('first') ||
                   sentence.toLowerCase().includes('next') ||
                   sentence.toLowerCase().includes('then');
        }

        function extractProcessName(sentence) {
            const words = sentence.split(' ');
            const nameWords = words.slice(0, 5);
            return nameWords.join(' ');
        }

        // Extract examples
        function extractExamples(content) {
            const examples = [];
            const examplePatterns = [
                /(?:for example|for instance|such as|like|including)/gi,
                /(?:case study|use case|scenario)/gi
            ];
            
            examplePatterns.forEach(pattern => {
                const matches = content.match(pattern);
                if (matches) {
                    const sentences = content.split(/[.!?]+/);
                    sentences.forEach(sentence => {
                        if (pattern.test(sentence)) {
                            examples.push(sentence.trim());
                        }
                    });
                }
            });
            
            return examples;
        }

        // Extract best practices
        function extractBestPractices(content) {
            const bestPractices = [];
            const practicePatterns = [
                /(?:best practice|recommended|should|always|never)/gi,
                /(?:tip|advice|guideline|standard)/gi
            ];
            
            practicePatterns.forEach(pattern => {
                const sentences = content.split(/[.!?]+/);
                sentences.forEach(sentence => {
                    if (pattern.test(sentence)) {
                        bestPractices.push(sentence.trim());
                    }
                });
            });
            
            return bestPractices;
        }

        // Extract question-answer pairs
        function extractQuestionAnswerPairs(content) {
            const qaPairs = [];
            const sentences = content.split(/[.!?]+/);
            
            for (let i = 0; i < sentences.length - 1; i++) {
                const current = sentences[i].trim();
                const next = sentences[i + 1].trim();
                
                if (isQuestion(current) && isAnswer(next)) {
                    qaPairs.push({
                        question: current,
                        answer: next,
                        confidence: 0.8
                    });
                }
            }
            
            return qaPairs;
        }

        function isQuestion(sentence) {
            return sentence.includes('?') || 
                   sentence.toLowerCase().startsWith('what') ||
                   sentence.toLowerCase().startsWith('how') ||
                   sentence.toLowerCase().startsWith('why') ||
                   sentence.toLowerCase().startsWith('when') ||
                   sentence.toLowerCase().startsWith('where');
        }

        function isAnswer(sentence) {
            return sentence.length > 20 && 
                   (sentence.toLowerCase().includes('is') ||
                    sentence.toLowerCase().includes('are') ||
                    sentence.toLowerCase().includes('can') ||
                    sentence.toLowerCase().includes('will'));
        }

        // Store document learning data in Supabase
        async function storeDocumentLearningData(documentId, learningData) {
            try {
                // Store training data from Q&A pairs
                for (const qaPair of learningData.qa_pairs) {
                    await storeTrainingData({
                        input_text: qaPair.question,
                        expected_output: qaPair.answer,
                        training_type: 'document',
                        quality_score: qaPair.confidence,
                        is_validated: true,
                        source_document_id: documentId
                    });
                }
                
                // Store learning patterns
                for (const concept of learningData.key_concepts) {
                    await storeLearningPattern({
                        pattern_type: 'key_concept',
                        pattern_data: { concept: concept },
                        confidence_score: 0.8,
                        source_document_id: documentId
                    });
                }
                
                // Store business processes
                for (const process of learningData.processes) {
                    await storeLearningPattern({
                        pattern_type: 'business_process',
                        pattern_data: process,
                        confidence_score: 0.9,
                        source_document_id: documentId
                    });
                }
                
            } catch (error) {
                console.error('[OWNER] Error storing document learning data:', error);
            }
        }

        // Store training data
        async function storeTrainingData(trainingData) {
            try {
                const response = await fetch('/api/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        action: 'store-training-data',
                        data: trainingData
                    })
                });
                
                if (response.ok) {
                }
            } catch (error) {
                console.error('[OWNER] Error storing training data:', error);
            }
        }

        // Store learning pattern
        async function storeLearningPattern(patternData) {
            try {
                const response = await fetch('/api/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        action: 'store-learning-pattern',
                        data: patternData
                    })
                });
                
                if (response.ok) {
                }
            } catch (error) {
                console.error('[OWNER] Error storing learning pattern:', error);
            }
        }

        // Debounce helper
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Debounced load functions
        const debouncedLoadLearningMetrics = debounce(loadLearningMetrics, 500);
        const debouncedLoadEpsilonLearning = debounce(loadEpsilonLearning, 500);

        async function loadLearningMetrics() {
            const grid = document.getElementById('learningMetricsGrid');
            const footnote = document.getElementById('learningMetricsFootnote');

            if (!grid) return;

            try {
                grid.innerHTML = '<div class="loading">Calculating learning metrics...</div>';
                if (footnote) footnote.textContent = '';

                const response = await fetch('/api/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        action: 'get-learning-metrics',
                        data: {}
                    })
                });

                if (!response.ok) {
                    if (response.status === 0 || response.status === 503) {
                        throw new Error('Server unavailable. Please check if the server is running.');
                    }
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                if (!data.success) {
                    throw new Error(data.error || 'Failed to load learning metrics');
                }

                renderLearningMetrics(data.metrics || {});
            } catch (error) {
                console.error('[OWNER] Error loading learning metrics:', error);
                if (grid) {
                    const errorMsg = error.message.includes('Failed to fetch') || error.message.includes('ERR_CONNECTION_REFUSED')
                        ? 'Server is not running. Please start the local server.'
                        : error.message || 'Unknown error';
                    grid.innerHTML = `<div class="error-message">Unable to load learning metrics<br>${escapeHtml(errorMsg)}</div>`;
                }
                if (footnote) {
                    footnote.textContent = '';
                }
            }
        }

        function renderLearningMetrics(metrics = {}) {
            const grid = document.getElementById('learningMetricsGrid');
            const footnote = document.getElementById('learningMetricsFootnote');
            if (!grid) return;

            const totalChunks = metrics.chunks_total || 0;

            const cards = [
                metricCard(
                    'Documents Learned',
                    formatNumber(metrics.documents_total || 0),
                    `Last 7 days: ${formatNumber(metrics.documents_last_7_days || 0)}`,
                    metrics.last_document_at ? `Last ingest: ${formatDateTime(metrics.last_document_at)}` : ''
                ),
                metricCard(
                    'Knowledge Chunks',
                    formatNumber(totalChunks),
                    totalChunks ? `Sales: ${formatShare(metrics.sales_chunks || 0, totalChunks)} · Technical: ${formatShare(metrics.technical_chunks || 0, totalChunks)}` : 'No chunks processed yet',
                    totalChunks ? `Testimonials: ${formatShare(metrics.testimonial_chunks || 0, totalChunks)} · General: ${formatShare(metrics.general_chunks || 0, totalChunks)}` : ''
                ),
                metricCard(
                    'User Feedback',
                    metrics.avg_feedback_rating ? metrics.avg_feedback_rating.toFixed(2) : '—',
                    `Responses: ${formatNumber(metrics.feedback_count || 0)}`,
                    metrics.avg_feedback_rating ? 'Target ≥ 4.5' : ''
                ),
                metricCard(
                    'Conversations (24h)',
                    formatNumber(metrics.conversations_24h || 0),
                    'Live learning sessions today',
                    ''
                )
            ];

            grid.innerHTML = cards.join('');

            if (footnote) {
                const updatedText = metrics.timestamp ? `Updated ${formatDateTime(metrics.timestamp)}` : '';
                const categoryDistribution = metrics.category_distribution || {};
                const summary = Object.entries(categoryDistribution)
                    .map(([category, count]) => `${category.replace(/_/g, ' ')} ${formatShare(count, totalChunks)}`)
                    .join(' • ');

                footnote.textContent = [updatedText, summary].filter(Boolean).join(' · ');
            }
        }

        function metricCard(label, value, subline, trend) {
            return `
                <div class="metric-card">
                    <span class="metric-label">${escapeHtml(label)}</span>
                    <span class="metric-value">${escapeHtml(value)}</span>
                    ${subline ? `<span class="metric-sub">${escapeHtml(subline)}</span>` : ''}
                    ${trend ? `<span class="metric-trend">${escapeHtml(trend)}</span>` : ''}
                </div>
            `;
        }

        async function loadDocuments() {
            const container = document.getElementById('documentsContainer');
            try {
                container.textContent = '';
                const loadingDiv = document.createElement('div');
                loadingDiv.className = 'loading';
                loadingDiv.textContent = 'Loading documents...';
                container.appendChild(loadingDiv);
                // FIXED: Removed token from localStorage.
                // Add cache-busting timestamp to prevent 304 responses
                const cacheBuster = `?t=${Date.now()}`;
                const response = await fetch(`/api/documents${cacheBuster}`, {
                    method: 'GET', // GET request for listing
                    headers: {
                        'Accept': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest(),
                        'Cache-Control': 'no-cache'
                    },
                    credentials: 'include',
                    cache: 'no-store'
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                
                if (!data || !data.documents) {
                    console.error('[OWNER] Invalid response format:', data);
                    throw new Error('Invalid response format from server');
                }
                
                if (data.documents.length === 0) {
                    console.warn('[OWNER] Server returned empty documents array');
                }
                
                documentsState.list = data.documents;
                if (!documentsState.list.length) {
                    documentsState.selectedId = null;
                } else if (!documentsState.selectedId || !documentsState.list.some(doc => doc.id === documentsState.selectedId)) {
                    documentsState.selectedId = documentsState.list[0]?.id || null;
                }
                displayDocuments(documentsState.list);
                
            } catch (error) {
                console.error('Error loading documents:', error);
                documentsState.list = [];
                documentsState.selectedId = null;
                container.textContent = '';
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'no-data';
                const p1 = document.createElement('p');
                p1.textContent = 'No documents uploaded yet';
                const p2 = document.createElement('p');
                p2.textContent = 'Upload your first document to get started with Epsilon AI\'s learning system';
                noDataDiv.appendChild(p1);
                noDataDiv.appendChild(p2);
                container.appendChild(noDataDiv);
            }
        }

        function displayDocuments(documents) {
            const container = document.getElementById('documentsContainer');
            if (!container) {
                console.error('[OWNER] documentsContainer element not found');
                return;
            }
            
            if (!documents || documents.length === 0) {
                container.innerHTML = `
                    <div class="document-empty-state">
                        <p style="font-size: 1.1rem; margin-bottom: 0.25rem;">No documents uploaded yet</p>
                        <p style="color: rgba(255,255,255,0.7);">Upload your first document to get started with Epsilon AI's learning system.</p>
                    </div>
                `;
                return;
            }
            
            if (!documentsState.selectedId || !documents.some(doc => doc.id === documentsState.selectedId)) {
                documentsState.selectedId = documents[0]?.id || null;
            }
            
            container.innerHTML = `
                <div class="documents-panel">
                    <div class="document-select-container">
                        <label for="documentSelect" class="form-group" style="margin-bottom: 0.75rem;">
                            <span style="display: block; margin-bottom: 0.5rem; font-size: 0.9rem; color: rgba(255,255,255,0.8);">Select Document</span>
                            <select id="documentSelect" class="form-select" style="width: 100%;">
                                ${documents.map(doc => {
                                    const docType = doc.document_type || doc.doc_type || 'general';
                                    const fileSize = doc.file_size || 0;
                                    const createdAt = doc.created_at || new Date().toISOString();
                                    const displayText = `${escapeHtml(doc.title || 'Untitled Document')} (${escapeHtml(docType)} • ${formatFileSize(fileSize)} • ${formatDate(createdAt)})`;
                                    return `<option value="${doc.id}" ${doc.id === documentsState.selectedId ? 'selected' : ''}>${displayText}</option>`;
                                }).join('')}
                            </select>
                        </label>
                    </div>
                    <div class="document-detail-card" id="documentDetail"></div>
                </div>
            `;
            
            const selectEl = document.getElementById('documentSelect');
            if (selectEl) {
                selectEl.addEventListener('change', (e) => {
                    handleDocumentSelection(e.target.value);
                });
            }
            
            const initialDoc = documents.find(doc => doc.id === documentsState.selectedId) || documents[0];
            renderDocumentDetail(initialDoc);
        }

        function handleDocumentSelection(docId) {
            documentsState.selectedId = docId;
            const selectEl = document.getElementById('documentSelect');
            if (selectEl) {
                selectEl.value = docId;
            }
            const selectedDoc = documentsState.list.find(doc => doc.id === docId);
            renderDocumentDetail(selectedDoc);
        }

        function renderDocumentDetail(doc) {
            const detailEl = document.getElementById('documentDetail');
            if (!detailEl) return;
            
            if (!doc) {
                detailEl.innerHTML = `<div class="document-empty-state">Select a document to view its details.</div>`;
                return;
            }
            
            const docType = doc.document_type || doc.doc_type || 'general';
            const fileSize = doc.file_size || 0;
            const createdAt = doc.created_at || new Date().toISOString();
            let metadata = doc.learning_metadata || {};
            if (typeof metadata === 'string') {
                try {
                    metadata = JSON.parse(metadata);
                } catch {
                    metadata = {};
                }
            }
            const tags = Array.isArray(metadata.tags)
                ? metadata.tags
                : typeof metadata.tags === 'string'
                    ? metadata.tags.split(',').map(tag => tag.trim()).filter(Boolean)
                    : [];
            const status = metadata.learning_status || doc.learning_status || 'pending';
            const category = metadata.learning_category || docType || 'general';
            
            detailEl.innerHTML = `
                <div class="document-detail-header">
                    <div>
                        <p style="margin: 0; font-size: 0.85rem; color: rgba(255,255,255,0.6);">Document Title</p>
                        <h3 style="margin: 0.25rem 0 0;">${escapeHtml(doc.title || 'Untitled Document')}</h3>
                    </div>
                    <span class="document-type-pill">${escapeHtml(docType)}</span>
                </div>
                
                <div class="document-detail-meta">
                    <div>
                        <p>Uploaded</p>
                        <strong>${formatDateTime(createdAt)}</strong>
                    </div>
                    <div>
                        <p>Size</p>
                        <strong>${formatFileSize(fileSize)}</strong>
                    </div>
                    <div>
                        <p>Category</p>
                        <strong>${escapeHtml(category)}</strong>
                    </div>
                    <div>
                        <p>Status</p>
                        <strong style="text-transform: capitalize;">${escapeHtml(status)}</strong>
                    </div>
                </div>
                
                <div class="document-tags">
                    ${tags.length ? tags.map(tag => `<span class="document-tag">${escapeHtml(tag)}</span>`).join('') : '<span style="color: rgba(255,255,255,0.6); font-size: 0.85rem;">No tags added</span>'}
                </div>
                
                <div class="document-action-row">
                    <button type="button" class="action-btn outline verify-doc-btn">Verify Content</button>
                    <button type="button" class="delete-btn delete-doc-btn">Delete Document</button>
                </div>
            `;
            
            const verifyBtn = detailEl.querySelector('.verify-doc-btn');
            if (verifyBtn) {
                verifyBtn.addEventListener('click', () => verifyDocumentContent(doc.id));
            }
            
            const deleteBtn = detailEl.querySelector('.delete-doc-btn');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', () => deleteDocument(doc.id, doc.title || 'Untitled Document'));
            }
        }

        async function verifyDocumentContent(docId) {
            // Safety check: validate docId
            if (!docId || typeof docId !== 'string' || docId.length > 100) {
                alert('Invalid document ID.');
                return;
            }
            try {
                // FIXED: Removed token from localStorage.
                // XSS protection: encode docId in URL
                const encodedDocId = encodeURIComponent(docId);
                const response = await fetch(`/api/documents?id=${encodedDocId}&action=verify`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include'
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                alert(`Document content verified. Length: ${formatNumber(data.contentLength || 0)} characters.`);
            } catch (error) {
                console.error('Error verifying document: ' + error.message);
                alert(`Could not verify document: ${error.message}`);
            }
        }

        async function deleteDocument(docId, docName) {
            // Safety check: validate docId
            if (!docId || typeof docId !== 'string' || docId.length > 100) {
                alert('Invalid document reference.');
                return;
            }
            // Safety check: validate docName
            if (!docName || typeof docName !== 'string' || docName.length > 500) {
                alert('Invalid document name.');
                return;
            }
            // XSS protection: use textContent for confirmation
            const safeDocName = docName.substring(0, 100);
            if (!confirm(`Delete "${safeDocName}" from Epsilon AI's knowledge base?`)) {
                return;
            }
            try {
                const response = await fetch(`/api/documents?id=${docId}`, {
                    method: 'DELETE',
                    headers: {
                        'Accept': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include'
                });
                if (response.ok) {
                    alert('Document deleted successfully.');
                    await loadDocuments();
                } else {
                    const errorData = await response.json();
                    throw new Error(errorData.error);
                }
            } catch (error) {
                console.error('Error deleting document: ' + error.message);
                if (error.message && error.message.toLowerCase().includes('not found')) {
                    alert('Document was already removed. Refreshing list.');
                    await loadDocuments();
                } else {
                    alert(`Failed to delete document: ${error.message}`);
                }
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatDate(dateString) {
            if (!dateString) return 'Unknown';
            return new Date(dateString).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        }

        function formatDateTime(dateString) {
            if (!dateString) return 'Unknown';
            const date = new Date(dateString);
            if (Number.isNaN(date.getTime())) return 'Unknown';
            return date.toLocaleString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function formatNumber(value) {
            if (!Number.isFinite(value)) return '0';
            if (Math.abs(value) >= 1000000) {
                return `${(value / 1000000).toFixed(1)}M`;
            }
            if (Math.abs(value) >= 1000) {
                return `${(value / 1000).toFixed(1)}k`;
            }
            return Number(value).toLocaleString();
        }

        function formatShare(count, total) {
            if (!total || !Number.isFinite(count)) return '0%';
            return `${((count / total) * 100).toFixed(1)}%`;
        }

        function formatFileSize(bytes) {
            if (!bytes || bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        document.addEventListener('DOMContentLoaded', () => {
            initializeDragAndDrop();
            initializeDashboard();
            
            // Initialize owner profile circle with avatar support
            initOwnerProfileBubble();
            
            // Owner logout button
            const ownerLogout = document.getElementById('ownerLogout');
            if (ownerLogout) {
                ownerLogout.addEventListener('click', function(e) {
                    e.preventDefault();
                    logout();
            });
            }
            
            setActiveNavLink();
            syncNavUserState();
            loadOwnerProfile();
            
            // Add event listeners for buttons
            const refreshBtnEl = document.getElementById('refreshBtn');
            if (refreshBtnEl) {
                refreshBtnEl.addEventListener('click', () => {
                    loadAnalytics().catch(console.error);
                    loadLearningMetrics().catch(console.error);
                });
            }
            document.getElementById('refreshDocumentsBtn').addEventListener('click', loadDocuments);
            document.getElementById('uploadArea').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });
            
            // Add event listeners for form fields
            document.getElementById('learningCategory').addEventListener('change', updateUploadButton);
            document.getElementById('docType').addEventListener('change', updateUploadButton);
            
            // Add event listeners for new buttons (only if element exists)
            const logoutBtn = document.getElementById('logoutBtn');
            if (logoutBtn) {
                logoutBtn.addEventListener('click', logout);
            }
            
            // Profile dropdown functionality
            const profileBtn = document.getElementById('profileBtn');
            const profileMenu = document.getElementById('profileMenu');
            
            if (profileBtn && profileMenu) {
                profileBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    profileMenu.classList.toggle('show');
                    profileBtn.classList.toggle('active');
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', function(e) {
                    if (!profileBtn.contains(e.target) && !profileMenu.contains(e.target)) {
                        profileMenu.classList.remove('show');
                        profileBtn.classList.remove('active');
                    }
                });
                
                // Handle edit profile button
                const editProfileBtn = document.getElementById('editProfileBtn');
                if (editProfileBtn) {
                    editProfileBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        window.location.href = '/edit_profile.html';
                        profileMenu.classList.remove('show');
                        profileBtn.classList.remove('active');
                    });
                }
            }
            const crmComingBtn = document.getElementById('crmComingBtn');
            if (crmComingBtn) {
                crmComingBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    alert('NeuralOps CRM workspace is in development. Stay tuned for updates!');
                });
            }
            const downloadAnalyticsBtn = document.getElementById('downloadAnalyticsBtn');
            const viewUsersBtn = document.getElementById('viewUsersBtn');
            
            if (downloadAnalyticsBtn) downloadAnalyticsBtn.addEventListener('click', downloadAnalytics);
            if (viewUsersBtn) viewUsersBtn.addEventListener('click', viewUsers);
            
            // Automatic training status monitoring (no manual buttons - Epsilon AI trains automatically)
            startAutomaticTrainingStatusMonitor();
            
            // Load self-learning progress on page load
            loadSelfLearningProgress();
            const fileInput = document.getElementById('fileInput');
            const uploadBtn = document.getElementById('uploadBtn');
            const refreshEpsilonLearningBtn = document.getElementById('refreshEpsilonLearningBtn');
            const exportEpsilonLearningBtn = document.getElementById('exportEpsilonLearningBtn');
            const triggerEpsilonLearningBtn = document.getElementById('triggerEpsilonLearningBtn');
            const refreshLearningBtn = document.getElementById('refreshLearningBtn');
            const modalCloseBtn = document.getElementById('modalCloseBtn');
            
            if (fileInput) fileInput.addEventListener('change', handleFileSelect);
            if (uploadBtn) uploadBtn.addEventListener('click', uploadDocuments);
            if (refreshEpsilonLearningBtn) refreshEpsilonLearningBtn.addEventListener('click', refreshEpsilonLearning);
            if (exportEpsilonLearningBtn) exportEpsilonLearningBtn.addEventListener('click', exportEpsilonLearning);
            if (triggerEpsilonLearningBtn) triggerEpsilonLearningBtn.addEventListener('click', triggerEpsilonLearning);
            if (refreshLearningBtn) refreshLearningBtn.addEventListener('click', refreshAdvancedLearning);
            if (modalCloseBtn) modalCloseBtn.addEventListener('click', closeModal);
            
            // Event delegation for document buttons
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('verify-doc-btn')) {
                    const docId = e.target.getAttribute('data-doc-id');
                    verifyDocumentContent(docId);
                } else if (e.target.classList.contains('delete-doc-btn')) {
                    const docId = e.target.getAttribute('data-doc-id');
                    const docTitle = e.target.getAttribute('data-doc-title');
                    deleteDocument(docId, docTitle);
                }
            });
            
            setInterval(() => {
                if (isInitialized) {
                    loadAnalytics().catch(console.error);
                    loadLearningMetrics().catch(console.error);
                }
            }, 5 * 60 * 1000);
        });

        document.getElementById('userModal').addEventListener('click', (e) => {
            if (e.target.classList.contains('modal-overlay')) {
                closeModal();
            }
        });

        window.addEventListener('online', () => updateConnectionStatus('connected', 'Connection restored'));
        window.addEventListener('offline', () => updateConnectionStatus('disconnected', 'Offline'));

        // Epsilon AI Learning Functions
        async function loadEpsilonLearning() {
            try {
                
                const response = await fetch('/api/epsilon-llm/status', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    if (response.status === 0 || response.status === 503) {
                        throw new Error('Language model service unavailable');
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const modelStatus = await response.json();
                
                // Also get learning stats from Supabase
                try {
                    const statsResponse = await fetch('/api/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                            'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include',
                    body: JSON.stringify({ 
                        action: 'get-epsilon-learning-stats',
                        data: {}
                    })
                });
                
                    let stats = {};
                    if (statsResponse.ok) {
                        const statsData = await statsResponse.json();
                        if (statsData.success) {
                            stats = statsData.stats || {};
                }
                    }
                    
                    // Combine model status with learning stats
                    const combinedStats = {
                        ...stats,
                        model_ready: modelStatus.ready || false,
                        vocab_size: modelStatus.vocab_size || 0,
                        samples_trained: modelStatus.samples_trained || 0,
                        model_type: modelStatus.model_type || 'none',
                        training_loss: modelStatus.training_loss || null,
                        epochs_trained: modelStatus.epochs_trained || 0
                    };
                    
                    displayEpsilonLearningStats(combinedStats);
                } catch (statsError) {
                    // If stats fail, still show model status
                    displayEpsilonLearningStats({
                        model_ready: modelStatus.ready || false,
                        vocab_size: modelStatus.vocab_size || 0,
                        samples_trained: modelStatus.samples_trained || 0,
                        model_type: modelStatus.model_type || 'none'
                    });
                }
                
            } catch (error) {
                console.error('[OWNER] Error loading Epsilon AI learning data:', error);
                const container = document.getElementById('epsilon-learning-container');
                if (container) {
                    container.textContent = '';
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error-message';
                    const p1 = document.createElement('p');
                    p1.textContent = 'Failed to load Epsilon AI learning analytics';
                    const p2 = document.createElement('p');
                    const errorMsg = error.message.includes('Failed to fetch') || error.message.includes('ERR_CONNECTION_REFUSED')
                        ? 'Server is not running. Please start the local server.'
                        : error.message;
                    p2.textContent = 'Error: ' + errorMsg;
                    errorDiv.appendChild(p1);
                    errorDiv.appendChild(p2);
                    container.appendChild(errorDiv);
                }
            }
        }

        function displayEpsilonLearningStats(stats) {
            // Add a small delay to ensure DOM is fully loaded
            let container = document.getElementById('epsilon-learning-container');
            
            if (!container) {
                console.warn('epsilon-learning-container element not found, waiting...');
                // Try again after a short delay
                setTimeout(() => {
                    container = document.getElementById('epsilon-learning-container');
                    if (!container) {
                        console.error('epsilon-learning-container still not found after retry');
                        return;
                    }
                    displayStatsInContainer(stats, container);
                }, 100);
                return;
            }
            
            displayStatsInContainer(stats, container);
        }
        
        function displayStatsInContainer(stats, container) {
            
            if (!stats || Object.keys(stats).length === 0) {
                container.textContent = '';
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'no-data';
                const p1 = document.createElement('p');
                p1.textContent = 'No Epsilon AI learning data available yet';
                const p2 = document.createElement('p');
                p2.textContent = 'Start conversations with Epsilon AI to begin collecting learning data';
                noDataDiv.appendChild(p1);
                noDataDiv.appendChild(p2);
                container.appendChild(noDataDiv);
                return;
            }
            
            const avgRating = stats.avg_rating ? stats.avg_rating.toFixed(1) : 'N/A';
            const helpfulPercentage = stats.helpful_percentage ? stats.helpful_percentage.toFixed(1) : 'N/A';
            const avgResponseTime = stats.avg_response_time ? Math.round(stats.avg_response_time) : 'N/A';
            
            const modelStatus = stats.model_ready ? 'Trained' : 'Not Trained';
            const vocabDisplay = stats.vocab_size ? formatNumber(stats.vocab_size) : '0';
            const samplesDisplay = stats.samples_trained ? formatNumber(stats.samples_trained) : '0';
            
            container.innerHTML = `
                <div class="epsilon-learning-stats">
                    <div class="stat-grid">
                        <div class="stat-item">
                            <div class="stat-value">${stats.total_messages || 0}</div>
                            <div class="stat-label">Total Messages</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${avgRating}</div>
                            <div class="stat-label">Average Rating</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${helpfulPercentage}%</div>
                            <div class="stat-label">Helpful Responses</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${modelStatus}</div>
                            <div class="stat-label">Model Status</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${vocabDisplay}</div>
                            <div class="stat-label">Vocabulary Size</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${samplesDisplay}</div>
                            <div class="stat-label">Samples Trained</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${stats.model_type || 'none'}</div>
                            <div class="stat-label">Model Type</div>
                        </div>
                        ${stats.training_loss !== null ? `
                        <div class="stat-item">
                            <div class="stat-value">${stats.training_loss.toFixed(4)}</div>
                            <div class="stat-label">Training Loss</div>
                        </div>
                        ` : ''}
                        ${stats.epochs_trained > 0 ? `
                        <div class="stat-item">
                            <div class="stat-value">${stats.epochs_trained}</div>
                            <div class="stat-label">Epochs Trained</div>
                        </div>
                        ` : ''}
                    </div>
                    
                    <div class="learning-insights" style="margin-top: 2rem;">
                        <h3 style="color: var(--neural-text); margin-bottom: 1rem;">Learning Insights</h3>
                        <div id="learning-insights-content">
                            <div class="loading">Loading insights...</div>
                        </div>
                    </div>
                </div>
            `;
            
            // Load additional insights
            loadEpsilonLearningInsights();
            loadAdvancedLearningInsights();
            // Models auto-approve - no pending list needed
        }

        async function loadEpsilonLearningInsights() {
            try {
                const response = await fetch('/api/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
                    },
                    credentials: 'include',
                    body: JSON.stringify({ 
                        action: 'get-epsilon-learning-insights',
                        data: {}
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.success && data.insights) {
                    displayEpsilonLearningInsights(data.insights);
                }
                
            } catch (error) {
                console.error('[OWNER] Error loading Epsilon AI learning insights:', error);
                const container = document.getElementById('learning-insights-content');
                if (container) {
                    container.textContent = '';
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error-message';
                    const p = document.createElement('p');
                    p.textContent = 'Failed to load learning insights';
                    errorDiv.appendChild(p);
                    container.appendChild(errorDiv);
                }
            }
        }

        function displayEpsilonLearningInsights(insights) {
            const container = document.getElementById('learning-insights-content');
            
            if (!container) {
                console.warn('learning-insights-content element not found');
                return;
            }
            
            if (!insights || insights.length === 0) {
                container.textContent = '';
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'no-data';
                const p1 = document.createElement('p');
                p1.textContent = 'No learning patterns detected yet';
                const p2 = document.createElement('p');
                p2.textContent = 'More conversation data needed for pattern analysis';
                noDataDiv.appendChild(p1);
                noDataDiv.appendChild(p2);
                container.appendChild(noDataDiv);
                return;
            }
            
            const insightsHtml = insights.map(insight => `
                <div class="insight-item" style="background: rgba(0,102,255,0.1); border: 1px solid rgba(0,102,255,0.2); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <h4 style="color: var(--neural-text); margin: 0;">${insight.pattern_type.replace('_', ' ').toUpperCase()}</h4>
                        <span style="color: var(--neural-success); font-weight: 600;">${insight.avg_confidence ? (insight.avg_confidence * 100).toFixed(1) + '%' : 'N/A'}</span>
                    </div>
                    <div style="color: var(--neural-muted); font-size: 0.9rem;">
                        <p>Patterns: ${insight.pattern_count}</p>
                        <p>Last Used: ${insight.last_used ? new Date(insight.last_used).toLocaleDateString() : 'N/A'}</p>
                    </div>
                </div>
            `).join('');
            
            container.innerHTML = insightsHtml;
        }

        async function refreshEpsilonLearning() {
            await loadEpsilonLearning();
        }

        // Advanced Learning System Functions
        async function loadAdvancedLearningInsights() {
            try {
                const response = await fetch('/api/advanced-learning/insights', {
                    method: 'GET',
                    credentials: 'include'
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                // Update UI elements
                updateAdvancedLearningUI(data);
            } catch (error) {
                console.error('[OWNER] Error loading advanced learning insights:', error);
                updateAdvancedLearningUI(null, error.message);
            }
        }

        function updateAdvancedLearningUI(data, error = null) {
            const elements = {
                learningStatus: document.getElementById('learningStatus'),
                totalDocuments: document.getElementById('totalDocuments'),
                successRate: document.getElementById('successRate'),
                userSatisfaction: document.getElementById('userSatisfaction'),
                featuresEnabled: document.getElementById('featuresEnabled')
            };

            if (error) {
                Object.values(elements).forEach(el => {
                    if (el) {
                        el.textContent = 'Error';
                        el.className = 'insight-value error';
                    }
                });
                return;
            }

            if (data) {
                if (elements.learningStatus) {
                    elements.learningStatus.textContent = data.learning_status || 'Unknown';
                    elements.learningStatus.className = 'insight-value online';
                }

                if (elements.totalDocuments) {
                    elements.totalDocuments.textContent = data.total_documents || '0';
                    elements.totalDocuments.className = 'insight-value';
                }

                if (elements.successRate) {
                    const rate = data.performance_metrics?.success_rate || 0;
                    elements.successRate.textContent = `${(rate * 100).toFixed(1)}%`;
                    elements.successRate.className = rate > 0.8 ? 'insight-value online' : 'insight-value warning';
                }

                if (elements.userSatisfaction) {
                    const satisfaction = data.performance_metrics?.user_satisfaction || 0;
                    elements.userSatisfaction.textContent = `${(satisfaction * 100).toFixed(1)}%`;
                    elements.userSatisfaction.className = satisfaction > 0.7 ? 'insight-value online' : 'insight-value warning';
                }

                if (elements.featuresEnabled) {
                    const features = data.features_enabled || [];
                    elements.featuresEnabled.textContent = `${features.length} features`;
                    elements.featuresEnabled.className = 'insight-value';
                }
            }
        }

        async function refreshAdvancedLearning() {
            await loadAdvancedLearningInsights();
        }

        // Load and display pending deployments
        // Removed loadPendingDeployments - models auto-approve after validation

        // Approval/reject functions removed - models auto-approve after validation

        // Load deployment history
        async function loadDeploymentHistory() {
            try {
                const container = document.getElementById('deployment-history-container');
                if (!container) return;

                const response = await fetch('/api/epsilon-llm/deploys/history', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include'
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                if (!result.success) {
                    throw new Error(result.error || 'Failed to load deployment history');
                }

                const history = result.deploys || [];

                if (history.length === 0) {
                    container.innerHTML = '<div class="no-data">No deployment history yet. Epsilon AI will create deployments as it improves!</div>';
                    return;
                }

                container.innerHTML = history.map(deploy => `
                    <div class="deployment-card" style="margin-bottom: 1rem; padding: 1.5rem; border: 1px solid var(--neural-border); border-radius: 8px; background: var(--neural-bg-secondary);">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                            <div>
                                <h3 style="margin: 0 0 0.5rem 0; color: var(--neural-text);">Version ${deploy.version}</h3>
                                <div style="display: flex; gap: 1rem; font-size: 0.85rem; color: rgba(255, 255, 255, 0.7);">
                                    <span>Quality: ${((deploy.quality_score || 0) * 100).toFixed(1)}%</span>
                                    <span>Improvement: +${((deploy.improvement || 0) * 100).toFixed(1)}%</span>
                                    <span>Samples: ${deploy.training_samples || 0}</span>
                                    <span style="padding: 0.25rem 0.5rem; border-radius: 4px; background: ${deploy.status === 'approved' ? 'rgba(0, 210, 140, 0.2)' : deploy.status === 'rejected' ? 'rgba(255, 76, 76, 0.2)' : 'rgba(0, 153, 255, 0.2)'}; color: ${deploy.status === 'approved' ? 'rgba(196, 255, 232, 0.9)' : deploy.status === 'rejected' ? 'rgba(255, 214, 214, 0.9)' : 'rgba(200, 225, 255, 0.9)'};">
                                        ${deploy.status === 'approved' ? 'Approved' : deploy.status === 'rejected' ? 'Rejected' : 'Pending'}
                                    </span>
                                </div>
                            </div>
                        </div>
                        ${deploy.learning_description ? `
                            <div style="margin-bottom: 1rem; padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 6px;">
                                <div style="font-weight: 600; margin-bottom: 0.5rem; color: var(--neural-text);">What Epsilon AI Learned:</div>
                                <div style="color: var(--neural-text-secondary); white-space: pre-wrap; line-height: 1.6;">${escapeHtml(deploy.learning_description)}</div>
                            </div>
                        ` : ''}
                        <div style="font-size: 0.85rem; color: rgba(255, 255, 255, 0.5);">
                            Created: ${new Date(deploy.created_at).toLocaleString()}
                            ${deploy.approved_at ? ` · Approved: ${new Date(deploy.approved_at).toLocaleString()}` : ''}
                            ${deploy.approved_by ? ` · By: ${escapeHtml(deploy.approved_by)}` : ''}
                        </div>
                    </div>
                `).join('');
            } catch (error) {
                console.error('[OWNER] Error loading deployment history:', error);
                const container = document.getElementById('deployment-history-container');
                if (container) {
                    container.innerHTML = `<div class="error">Failed to load deployment history: ${error.message}</div>`;
                }
            }
        }

        // Automatic training status monitor
        function startAutomaticTrainingStatusMonitor() {
            updateTrainingStatus();
            // Update every 5 seconds
            setInterval(updateTrainingStatus, 5000);
        }

        // Update training status display
        async function updateTrainingStatus() {
            try {
                const response = await fetch('/api/epsilon-llm/automatic-training/status', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': getCsrfTokenForRequest()
                    },
                    credentials: 'include'
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                if (!result.success || !result.status) {
                    return;
                }

                const status = result.status;
                const statusIcon = document.getElementById('trainingStatusIcon');
                const statusBadge = document.getElementById('trainingStatusBadge');
                const statusMessage = document.getElementById('trainingStatusMessage');
                const statusProgress = document.getElementById('trainingStatusProgress');
                const progressFill = document.getElementById('trainingProgressFill');
                const logEntries = document.getElementById('trainingLogEntries');
                const statusLog = document.getElementById('trainingStatusLog');
                const statusDetails = document.getElementById('trainingStatusDetails');

                // Update icon and badge
                if (status.isTraining) {
                    if (statusIcon) statusIcon.textContent = '⟳';
                    if (statusIcon) statusIcon.style.animation = 'pulse 2s infinite';
                    if (statusBadge) {
                        statusBadge.textContent = 'Training';
                        statusBadge.className = 'status-badge training';
                    }
                    if (statusMessage) statusMessage.textContent = status.message || 'Epsilon AI is currently training on new data...';
                    
                    // Show progress if available
                    if (statusProgress) {
                        statusProgress.style.display = 'block';
                        if (status.progress !== undefined && progressFill) {
                            progressFill.style.width = `${status.progress * 100}%`;
                        }
                    }
                } else {
                    if (statusIcon) statusIcon.textContent = '✓';
                    if (statusIcon) statusIcon.style.animation = 'none';
                    if (statusBadge) {
                        statusBadge.textContent = 'Idle';
                        statusBadge.className = 'status-badge idle';
                    }
                    
                    // Show detailed message with error info if available
                    let message = status.message || 'Epsilon AI is ready. Training will start automatically when new data is available.';
                    
                    // Add diagnostic info
                    if (status.diagnostics) {
                        if (!status.diagnostics.pythonServicesReady) {
                            message += ' Warning: Python services not ready.';
                        }
                        if (!status.diagnostics.modelReady && status.diagnostics.pythonServicesReady) {
                            message += ' Warning: Model not trained yet.';
                        }
                    }
                    
                    if (status.lastError) {
                        message += ` Error: ${status.lastError}`;
                    }
                    if (status.nextCycleIn !== null && status.nextCycleIn > 0) {
                        const minutes = Math.ceil(status.nextCycleIn / 60000);
                        message += ` Next cycle in ~${minutes} min.`;
                    }
                    if (statusMessage) statusMessage.textContent = message;
                    
                    // Add manual trigger button if idle and not running
                    if (!status.isTraining && status.isRunning) {
                        const existingTrigger = document.getElementById('manualTriggerBtn');
                        if (!existingTrigger) {
                            const triggerBtn = document.createElement('button');
                            triggerBtn.id = 'manualTriggerBtn';
                            triggerBtn.textContent = 'Trigger Training Now';
                            triggerBtn.style.cssText = 'margin-top: 1rem; padding: 0.5rem 1rem; background: rgba(249, 115, 22, 0.08); border: 1px solid var(--flame-core); color: #F97316; border-radius: 6px; cursor: pointer;';
                            triggerBtn.onclick = async () => {
                                triggerBtn.disabled = true;
                                triggerBtn.textContent = 'Triggering...';
                                try {
                                    const response = await fetch('/api/epsilon-llm/automatic-training/trigger', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                            'X-CSRF-Token': getCsrfTokenForRequest()
                                        },
                                        credentials: 'include'
                                    });
                                    const result = await response.json();
                                    if (result.success) {
                                        triggerBtn.textContent = 'Triggered!';
                                        setTimeout(() => {
                                            triggerBtn.textContent = 'Trigger Training Now';
                                            triggerBtn.disabled = false;
                                            updateTrainingStatus();
                                        }, 2000);
                                    } else {
                                        alert('Failed to trigger training: ' + (result.error || 'Unknown error'));
                                        triggerBtn.textContent = 'Trigger Training Now';
                                        triggerBtn.disabled = false;
                                    }
                                } catch (error) {
                                    alert('Error triggering training: ' + error.message);
                                    triggerBtn.textContent = 'Trigger Training Now';
                                    triggerBtn.disabled = false;
                                }
                            };
                            if (statusDetails) {
                                statusDetails.appendChild(triggerBtn);
                            }
                        }
                    } else {
                        const existingTrigger = document.getElementById('manualTriggerBtn');
                        if (existingTrigger) {
                            existingTrigger.remove();
                        }
                    }
                    
                    if (statusProgress) {
                        statusProgress.style.display = 'none';
                    }
                }

                // Update log entries
                if (status.deployHistory && status.deployHistory.length > 0) {
                    if (statusLog) statusLog.style.display = 'block';
                    if (logEntries) {
                        logEntries.innerHTML = status.deployHistory.slice(-10).reverse().map(entry => {
                            const statusClass = entry.status === 'approved' ? 'success' : entry.status === 'rejected' ? 'error' : '';
                            return `
                                <div class="log-entry ${statusClass}">
                                    <div>Version ${entry.version} - ${entry.status === 'approved' ? 'Approved' : entry.status === 'rejected' ? 'Rejected' : 'Pending'}</div>
                                    <div class="log-entry-time">${new Date(entry.timestamp).toLocaleString()}</div>
                                </div>
                            `;
                        }).join('');
                    }
                } else {
                    if (statusLog) statusLog.style.display = 'none';
                }
            } catch (error) {
                console.error('[OWNER] Error updating training status:', error);
                const statusMessage = document.getElementById('trainingStatusMessage');
                if (statusMessage) {
                    statusMessage.textContent = 'Unable to fetch training status. Check server connection.';
                }
            }
        }

        async function exportEpsilonLearning() {
            try {
                
                const response = await fetch('/api/supabase-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
                    },
                    credentials: 'include',
                    body: JSON.stringify({ 
                        action: 'get-epsilon-dashboard-data',
                        data: {}
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    // Create downloadable JSON file
                    const blob = new Blob([JSON.stringify(data.dashboard_data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `epsilon-learning-data-${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                } else {
                    throw new Error(data.error || 'Failed to export Epsilon AI learning data');
                }
                
            } catch (error) {
                console.error('[OWNER] Error exporting Epsilon AI learning data:', error);
                console.error('Failed to export Epsilon AI learning data: ' + error.message);
            }
        }

        async function triggerEpsilonLearning() {
            try {
                
                // This would trigger a learning session in a real implementation
                
                // Refresh the learning data after triggering
                await refreshEpsilonLearning();
                
            } catch (error) {
                console.error('[OWNER] Error triggering Epsilon AI learning update:', error);
                console.error('Failed to trigger Epsilon AI learning update: ' + error.message);
            }
        }

        function updateTrainStatus(state, message) {
            const statusEl = document.getElementById('trainEpsilonStatus');
            if (!statusEl) return;

            statusEl.classList.remove('status-info', 'status-success', 'status-error');
            const textEl = statusEl.querySelector('.status-text');
            if (textEl) textEl.textContent = message || '';

            if (!message) {
                statusEl.style.display = 'none';
                return;
            }

            switch (state) {
                case 'info':
                    statusEl.classList.add('status-info');
                    break;
                case 'success':
                    statusEl.classList.add('status-success');
                    break;
                case 'error':
                    statusEl.classList.add('status-error');
                    break;
                default:
                    statusEl.classList.add('status-info');
            }

            statusEl.style.display = 'flex';
        }

        async function handleTrainEpsilon() {
            // Safety check: validate button element
            const btn = document.getElementById('trainEpsilonBtn');
            if (!btn || btn.dataset.state === 'loading') return;

            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '';
            btn.dataset.state = 'loading';
            btn.textContent = 'Training Epsilon AI...';
            btn.disabled = true;
            updateTrainStatus('info', 'Training job started. Collecting latest documents and conversations…');

            try {
                const response = await fetch('/api/epsilon-llm/train', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    credentials: 'include'
                });

                const result = await response.json();
                if (!response.ok || !result.success) {
                    // Show helpful message if training is blocked (local-only)
                    if (result.blocked || result.error?.includes('local-only')) {
                        throw new Error(result.message || result.error || 'Training is local-only. Use ml_local/train/pretrain.py for training.');
                    }
                    throw new Error(result.error || `Training failed with status ${response.status}`);
                }

                // Handle queued case (training already in progress)
                if (result.queued === true) {
                    btn.dataset.state = 'info';
                    btn.textContent = 'Training in Progress...';
                    updateTrainStatus('info', result.message || 'Training is already in progress. Please wait for it to complete.');
                    
                    // Show current stats if available
                    const stats = result.stats || {};
                    if (stats.vocab > 0 || stats.samples > 0) {
                        const vocabSize = stats.vocab || stats.vocab_size || 0;
                        const samples = stats.samples || stats.samples_trained || 0;
                        updateTrainStatus('info', `${result.message || 'Training in progress...'} Current model: ${vocabSize} vocab, ${samples} samples.`);
                    }
                    
                    btn.disabled = false; // Allow user to check status again
                    return;
                }

                btn.dataset.state = 'success';
                btn.textContent = 'Epsilon AI Trained ✓';
                
                // Show detailed training stats
                const stats = result.stats || {};
                const vocabSize = stats.vocab || stats.vocab_size || 0;
                const samples = stats.samples || stats.samples_trained || 0;
                const categories = stats.categories || {};
                const categoryCount = Object.keys(categories).length;
                
                let statsMessage = `Training complete! `;
                if (vocabSize > 0) statsMessage += `Vocab: ${vocabSize} words, `;
                if (samples > 0) statsMessage += `Samples: ${samples}, `;
                if (categoryCount > 0) statsMessage += `Categories: ${categoryCount}`;
                statsMessage += `. Model is ready!`;
                
                updateTrainStatus('success', statsMessage);

                await Promise.allSettled([
                    loadLearningMetrics(),
                    loadEpsilonLearning(),
                    refreshAdvancedLearning(),
                    loadDeploymentHistory()
                ]);

                setTimeout(() => {
                    btn.dataset.state = 'ready';
                    btn.textContent = 'Train Epsilon AI';
                    btn.disabled = false;
                    updateTrainStatus('', '');
                }, 4000);
            } catch (error) {
                console.error('[OWNER] Epsilon AI training failed:', error);
                btn.dataset.state = 'error';
                btn.textContent = 'Retry Training';
                updateTrainStatus('error', error.message || 'Training failed. Please try again.');
                btn.disabled = false;
            }
        }

        async function handleStartSelfLearning() {
            const startBtn = document.getElementById('startSelfLearningBtn');
            const stopBtn = document.getElementById('stopSelfLearningBtn');
            if (!startBtn || startBtn.dataset.state === 'loading') return;

            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '';
            startBtn.dataset.state = 'loading';
            startBtn.textContent = 'Starting...';
            startBtn.disabled = true;

            try {
                const response = await fetch('/api/epsilon-llm/self-learning/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    credentials: 'include'
                });

                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Failed to start self-learning');
                }

                startBtn.style.display = 'none';
                if (stopBtn) stopBtn.style.display = 'inline-block';
                updateTrainStatus('success', 'Self-learning started! Epsilon AI will continuously improve itself.');
                
                // Refresh progress
                loadSelfLearningProgress();
            } catch (error) {
                console.error('[OWNER] Start self-learning failed:', error);
                startBtn.dataset.state = 'error';
                startBtn.textContent = 'Retry Start';
                updateTrainStatus('error', error.message || 'Failed to start self-learning');
                startBtn.disabled = false;
            }
        }

        async function handleStopSelfLearning() {
            const startBtn = document.getElementById('startSelfLearningBtn');
            const stopBtn = document.getElementById('stopSelfLearningBtn');
            if (!stopBtn || stopBtn.dataset.state === 'loading') return;

            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '';
            stopBtn.dataset.state = 'loading';
            stopBtn.textContent = 'Stopping...';
            stopBtn.disabled = true;

            try {
                const response = await fetch('/api/epsilon-llm/self-learning/stop', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    credentials: 'include'
                });

                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || 'Failed to stop self-learning');
                }

                stopBtn.style.display = 'none';
                if (startBtn) startBtn.style.display = 'inline-block';
                updateTrainStatus('info', 'Self-learning stopped.');
                
                // Refresh progress
                loadSelfLearningProgress();
            } catch (error) {
                console.error('[OWNER] Stop self-learning failed:', error);
                stopBtn.dataset.state = 'error';
                stopBtn.textContent = 'Retry Stop';
                updateTrainStatus('error', error.message || 'Failed to stop self-learning');
                stopBtn.disabled = false;
            }
        }

        async function loadSelfLearningProgress() {
            try {
                const response = await fetch('/api/epsilon-llm/self-learning/progress', {
                    credentials: 'include'
                });
                const result = await response.json();
                if (result.success && result.progress) {
                    const progress = result.progress;
                    const startBtn = document.getElementById('startSelfLearningBtn');
                    const stopBtn = document.getElementById('stopSelfLearningBtn');
                    
                    if (progress.isRunning) {
                        if (startBtn) startBtn.style.display = 'none';
                        if (stopBtn) stopBtn.style.display = 'inline-block';
                    } else {
                        if (startBtn) startBtn.style.display = 'inline-block';
                        if (stopBtn) stopBtn.style.display = 'none';
                    }
                    
                    // Display learning objectives if available
                    if (progress.objectives && progress.objectives.length > 0) {
                    }
                }
            } catch (error) {
                console.warn('[OWNER] Failed to load self-learning progress:', error);
            }
        }

        async function handleDeployEpsilon() {
            // Safety check: validate button element
            const btn = document.getElementById('deployEpsilonBtn');
            if (!btn || btn.dataset.state === 'loading') return;

            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '';
            const statusDiv = document.getElementById('deployEpsilonStatus');
            btn.dataset.state = 'loading';
            btn.textContent = 'Deploying...';
            btn.disabled = true;
            
            if (statusDiv) {
                statusDiv.style.display = 'block';
                statusDiv.querySelector('.status-text').textContent = 'Exporting model and uploading to Supabase...';
                statusDiv.querySelector('.status-dot').style.background = '#4a90e2';
            }

            try {
                // Create AbortController for timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 200000); // 200 seconds timeout
                
                const response = await fetch('/api/epsilon-llm/deploy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    credentials: 'include',
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);

                const result = await response.json();
                if (!response.ok || !result.success) {
                    throw new Error(result.error || `Deployment failed with status ${response.status}`);
                }

                btn.dataset.state = 'success';
                btn.textContent = 'Deployed ✓';
                if (statusDiv) {
                    statusDiv.querySelector('.status-text').textContent = 'Model deployed to Supabase! Render will load it on next restart.';
                    statusDiv.querySelector('.status-dot').style.background = '#00ff88';
                }

                setTimeout(() => {
                    btn.dataset.state = 'ready';
                    btn.textContent = 'Deploy to Render';
                    btn.disabled = false;
                    if (statusDiv) {
                        statusDiv.style.display = 'none';
                    }
                }, 5000);
            } catch (error) {
                console.error('[OWNER] Epsilon AI deployment failed:', error);
                btn.dataset.state = 'error';
                btn.textContent = 'Retry Deploy';
                if (statusDiv) {
                    let errorMessage = 'Deployment failed. Please try again.';
                    if (error.name === 'AbortError') {
                        errorMessage = 'Deployment timed out. The model may be too large. This can take up to 3 minutes.';
                    } else if (error.message) {
                        errorMessage = error.message;
                    }
                    statusDiv.querySelector('.status-text').textContent = errorMessage;
                    statusDiv.querySelector('.status-dot').style.background = '#ff4444';
                }
                btn.disabled = false;
            }
        }
    </script>
    
    <!-- Load required scripts -->
    <script src="/services/libs/supabase.js">    </script>

  <footer class="site-footer">
      <div class="footer-content">
          <div class="footer-left">
              <p>&copy; 2025 Neural Op's is a division of Neural Operations & Holdings LLC. All rights reserved.</p>
          </div>
          <div class="footer-right">
              <div class="footer-links">
                  <a href="/about" class="footer-link">About Us</a>
                  <span class="footer-divider">•</span>
                  <a href="/contact" class="footer-link">Contact</a>
                  <span class="footer-divider">•</span>
                  <a href="/privacy" class="footer-link">Privacy</a>
                  <span class="footer-divider">•</span>
                  <a href="/terms" class="footer-link">Terms of Service</a>
              </div>
          </div>
      </div>
  </footer>
</body>
</html>
